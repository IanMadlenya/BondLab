
  #-----------------------------------------------------------------------
  #Functions for the Cox, Ingersoll, Ross Single Factor Interest Rate Model
  #------------------------------------------------------------------------

  CIRBondPrice <- function(shortrate = vector(), T = numeric(), step = numeric(), kappa = numeric(), 
                           lambda = numeric(), sigma = numeric(), theta = numeric(), result = character){
    #Error trap the function
    
    if (missing(shortrate))
      stop("Need to specify shortrate.")
   
    # This error throws a warning in OAS
    #if (shortrate < 0 | shortrate > 1)
    #  stop("No valid interest.rate specified.")
    
    if (missing(T))
      stop("Need to specify maturity.")
    
    if (missing(step))
      stop("Need to specify step.")
    
    if (missing(kappa))
      stop("Need to specify kappa.")
    
    if (kappa < 0 | kappa > 1)
      stop("No valid kappa specified.")
    
    if (missing(lambda))
      stop("Need to specify lambda")
    
    if (lambda < 0 | lambda > 1)
      stop("No valid lambda specified.")
    
    if (missing(sigma))
      stop("Need to specify sigma")
    
    if (sigma < 0 | sigma > 1)
      stop("No valid sigma specified.")
    
    if (missing(theta))
      stop("Need to specify theta")
    
    if (theta < 0 | theta > 1)
      stop("No valid theta specified.")
    
    if(missing(result))
      result = "p"  
    
    #T is the maturity is the zero coupon bond. To price a coupon paying bond this is the maturity of the bond
    #step the time between each payment of a coupon paying bond
    
    #kappa is the rate of mean reversion  
    #lambda is the market risk premium (lambda must be negative)
    #sigma is interest rate variance - specificlly sigma^2
    #theta is the mean interest rate level
    #T is the vector of maturities of the yield curve each cash flow is treated as a zero coupon bond  
    #T = c(seq(from = step, to = T, by = step))
    
    T = if(step != 0) {c(seq(from = step, to = T, by = step))} else {T}
    
    #t is the start period this is the first step of the simulation as well as the step size
    #for example from t = 0 to the next period is 0 + step
    t = step
    
    #The below are the functions to determine the closed form solution to the CIR Model
    gamma = ((kappa + lambda)^2 + (2 * (sigma^2))) ^ (1/2)
    
    A.CIR = ((2 * gamma * exp(((kappa + lambda + gamma) * (T-t))/2)) 
             /
               ((gamma + lambda + kappa) * (exp(gamma * (T-t)) - 1) + (2 * gamma))) ^ ((2 * kappa * theta)/(sigma^2))
    
    B.CIR = ((2 * (exp(gamma * (T-t)) - 1))
             /
               ((gamma + lambda + kappa) * (exp(gamma * (T-t)) - 1) + (2 * gamma)))
    
    Price = A.CIR * exp((B.CIR * -1) * shortrate) 
    Yield = (shortrate * B.CIR  - log(A.CIR))/(T-t)
    Limit = (2* kappa* theta) /(gamma + kappa + lambda)
    
    CIRBondPrice = switch(result,
                          p = Price,
                          y = Yield,
                          l = Limit)  
    
  }
  
  CIRSim <- function(shortrate = numeric(), kappa = numeric(), theta = numeric(), 
                      T = numeric(), step = numeric(), sigma = numeric(), N = numeric()){
    
    #kappa is the rate of mean reversion
    #theta is the long term value of the short rate
    #T is the horizon
    #step is the time between each payment of coupon paying bond
    #N is the number of simulations
    
    #Error Trap Model Parameters
    if(2*kappa*theta < sigma^2) 
      stop("Invaild parameterization origin is inaccessible")
    
    dt <- step
    nrow <-  T/dt
    

    deltarate <- function(kappa = numeric(), theta = numeric(), dt = numeric(), sigma = numeric()){
    #Populate the first element of each path with the short rate
    #Euler discretization of the CIR model.  The discretization causes negative interest rates when 
    #when the short term rate approaches the origin.  To solve this problem take the absolute value of square root process  
    (kappa * (theta - simulation[i-1,j]) * dt) + (sigma * sqrt(abs(simulation[i-1,j])) * rnorm(1,0,1))}  
    
    #Matrix to hold the short rate paths - I can dimnames here rather than colnames same as mortgage oas (rename N to paths?)
    simulation = array(data = 0, c((nrow + 1), N))
          simulation[1,] = shortrate
    
    for(j in 1:N){
      for(i in 2:(nrow + 1)){        
        simulation[i,j] <- simulation[i-1, j] + deltarate(kappa = kappa, theta = theta, dt = dt, sigma = sigma)    
      }
    }
    
    colnames(simulation) <- c(rep((paste("path", seq(1:N)))))
    return(simulation)
  }
  
  #---------------------------------
  # Calibrate CIR to market
  #________________________________
  CalibrateCIR <- function(trade.date = character){
    
    #Call the desired curve from rates data folder
    CalCIR1 <- gzfile(description = paste("~/BondLab/RatesData/", as.Date(trade.date, "%m-%d-%Y"), ".rds", sep = ""), open = "rb")
    rates.data <- readRDS(CalCIR1)
    
    #set the column counter to make cashflows for termstrucutre
    ColCount <- as.numeric(ncol(rates.data))
    Mat.Years <- as.numeric(rates.data[2,2:ColCount])
    Coupon.Rate <- as.numeric(rates.data[1,2:ColCount])
    Issue.Date <- as.Date(rates.data[1,1])
    
    #initialize coupon bonds S3 class
    #This can be upgraded when bondlab has portfolio function
    ISIN <- vector()
    MATURITYDATE <- vector()
    ISSUEDATE <- vector()
    COUPONRATE <- vector()
    PRICE <- vector()
    ACCRUED <- vector()
    CFISIN <- vector()
    CF <- vector()
    DATE <- vector()
    CASHFLOWS  <- list(CFISIN,CF,DATE)
    names(CASHFLOWS) <- c("ISIN","CF","DATE")
    TODAY <- vector()
    data <- list()
    TSInput <- list()
    
    ### Assign Values to List Items #########
    data = NULL
    data$ISIN <- colnames(rates.data[2:ColCount])
    data$ISSUEDATE <- rep(as.Date(rates.data[1,1]),ColCount - 1)
    
    data$MATURITYDATE <-
      sapply(Mat.Years, function(Mat.Years = Mat.Years, Issue = Issue.Date) 
      {Maturity = if(Mat.Years < 1) {Issue %m+% months(round(Mat.Years * months.in.year))} else 
      {Issue %m+% years(as.numeric(Mat.Years))}
      return(as.character(Maturity))
      }) 
    
    data$COUPONRATE <- ifelse(Mat.Years < 1, 0, Coupon.Rate)                  
    
    #data$PRICE <- rep(100, ColCount -1)
    data$PRICE <- ifelse(Mat.Years < 1, (1 + (Coupon.Rate/100))^(Mat.Years * -1) * 100, 100)
    
    data$ACCRUED <- rep(0, ColCount -1)
    
    for(j in 1:(ColCount-1)){
      Vector.Length <- as.numeric(round(difftime(data[[3]][j],
                                                 data[[2]][j],
                                                 units = c("weeks"))/weeks.in.year,0))
      Vector.Length <- ifelse(Vector.Length < 1, 1, Vector.Length * pmt.frequency)  #pmt.frequency should be input 
      data$CASHFLOWS$ISIN <- append(data$CASHFLOWS$ISIN, rep(data[[1]][j],Vector.Length))
      data$CASHFLOWS$CF <- append(data$CASHFLOWS$CF,as.numeric(c(rep((data[[4]][j]/100/pmt.frequency),Vector.Length-1) * min.principal, (min.principal + (data$COUPONRATE[j]/100/pmt.frequency)* min.principal))))
      by.months = ifelse(data[[4]][j] == 0, round(difftime(data[[3]][j], rates.data[1,1])/days.in.month), 6) # this sets the month increment so that cashflows can handle discount bills
      data$CASHFLOWS$DATE <- append(data$CASHFLOW$DATE,seq(as.Date(rates.data[1,1]) %m+% months(as.numeric(by.months)), as.Date(data[[3]][j]), by = as.character(paste(by.months, "months", sep = " "))))
      
    } #The Loop Ends here and the list is made
    
    data$TODAY <- as.Date(rates.data[1,1])
    TSInput[[as.character(rates.data[1,1])]] <- c(data)
    
    #set term strucutre input (TSInput) to class couponbonds
    class(TSInput) <- "couponbonds"
    CashFlow <- TSInput[[1]]
    CIR.CF.Matrix <- create_cashflows_matrix(TSInput[[1]], include_price = TRUE)
    CIR.Mat.Matrix <- create_maturities_matrix(TSInput[[1]], include_price = TRUE )
    
    #Objective function
    CIRTune <- function(param = numeric(), shortrate = numeric(), sigma = .015, cfmatrix = matrix(), matmatrix = matrix()){
      kappa =  param[1]
      lambda = param[2]
      theta =  param[3]
      
      Disc <- CIRBondPrice(kappa = kappa, lambda = lambda, theta = theta, shortrate = shortrate, T= matmatrix,  step = 0, sigma = sigma)    
      CIRTune <- sqrt((sum(colSums((cfmatrix * Disc))^2))/ncol(matmatrix))
      return(CIRTune)
    }
    
    # Fit the model to the market   
    fit <- optimx(par = c(.1, .003, .03), 
                  fn = CIRTune, 
                  method = "L-BFGS-B",
                  lower = rep(.001, 3),
                  upper = rep(1, 3),
                  shortrate = .0016,
                  sigma = .015,
                  cfmatrix = CIR.CF.Matrix, 
                  matmatrix = CIR.Mat.Matrix)  
    close(CalCIR1)
    return(fit)
  }
  
  #-----------------------------------
  # Mortgage OAS Function
  #___________________________________
  
  Mortgage.OAS <- function(bond.id = "character", trade.date = "character", settlement.date = "character", original.bal = numeric(),
                          price = numeric(), short.rate = numeric(), sigma = numeric(), paths = numeric(), TermStructure = "character"){

    #The first step is to read in the Bond Detail, rates, and Prepayment Model Tuning Parameters
    conn1 <-  gzfile(description = paste("~/BondLab/BondData/",bond.id, ".rds", sep = ""), open = "rb")
    bond.id = readRDS(conn1)
    
    # Establish connection to mortgage rate model
    conn2 <- gzfile(description = "~/BondLab/PrepaymentModel/MortgageRate.rds", open = "rb")
    MortgageRate <- readRDS(conn2)
    
    # Establish connection to prepayment model tuning parameter
    conn3 <- gzfile(description = paste("~/BondLab/PrepaymentModel/", as.character(bond.id@Model), ".rds", sep =""), open = "rb")        
    ModelTune <- readRDS(conn3)
    
    #Call the desired curve from rates data folder
    conn4 <- gzfile(description = paste("~/BondLab/RatesData/", as.Date(trade.date, "%m-%d-%Y"), ".rds", sep = ""), open = "rb")
    rates.data <- readRDS(conn4)
               
    issue.date = as.Date(bond.id@IssueDate, "%m-%d-%Y")
    start.date = as.Date(bond.id@DatedDate, "%m-%d-%Y")
    end.date = as.Date(bond.id@Maturity, "%m-%d-%Y")
    lastpmt.date = as.Date(bond.id@LastPmtDate, "%m-%d-%Y")
    nextpmt.date = as.Date(bond.id@NextPmtDate, "%m-%d-%Y")
    coupon = bond.id@Coupon
    frequency = bond.id@Frequency
    delay = bond.id@PaymentDelay
    factor = bond.id@MBSFactor
    settlement.date = as.Date(c(settlement.date), "%m-%d-%Y")
    
    #The spot spread function is used to solve for the spread to the spot curve to normalize discounting
    #This function is encapasulated in term structure
    
    Spot.Spread <- function(spread = numeric(), cashflow = vector(), discount.rates = vector(), 
                            t.period = vector(), proceeds = numeric()){
      Present.Value <- sum((1/(1+(discount.rates + spread))^t.period) * cashflow)
      return(proceeds - Present.Value)
    }
          
    #First, calibrate the interest rate model to market swap rates and prices
    #Set trade date and call the CalibrateCIR Model
    #trade.date = as.Date(trade.date, "%m-%d-%Y")
    
    Market.Fit <- CalibrateCIR(trade.date = trade.date)
    kappa  = Market.Fit$p1
    lambda = Market.Fit$p2
    theta  = Market.Fit$p3
     
    
    #Calculate the number of cashflows that will be paid from settlement date to the last pmt date (used end date as next pmdt date for this)
    ncashflows = BondBasisConversion(issue.date = issue.date, start.date = start.date, end.date = end.date, settlement.date = settlement.date,
                                     lastpmt.date = lastpmt.date, nextpmt.date = end.date) 
    
    #Build a vector of dates for the payment schedule
    #first get the pmtdate interval
    pmtdate.interval = months.in.year/frequency
      
    #Compute the payment dates
    pmtdate = as.Date(c(if(settlement.date == issue.date) {seq(start.date, end.date, by = paste(pmtdate.interval, "months"))} 
                        else {seq(nextpmt.date, end.date, by = paste(pmtdate.interval, "months"))}), "%m-%d-%Y") + delay
    
    
    #Build the time period vector (n) for discounting the cashflows nextpmt date is vector of payment dates to n for each period
    time.period = BondBasisConversion(issue.date = issue.date, start.date = start.date, end.date = end.date, settlement.date = settlement.date,
                                      lastpmt.date = lastpmt.date, nextpmt.date = pmtdate)

    #step4 Count the number of cashflows 
    #num.periods is the total number of cashflows to be received
    #num.period is the period in which the cashflow is received
    num.periods = length(time.period)
    num.period = seq(1:num.periods)
        
    #==== Compute Option Adjusted Spread ==========================================
    #For simulation pass T = mortgage term if the number of paths = 1 then volatility = 0 
    Simulation <- CIRSim(shortrate = short.rate, kappa = kappa, theta = theta, T = ((num.periods-1) / months.in.year), step = (1/months.in.year), sigma = sigma, N = paths)
      
    #number of rows in the simulation will size the arrays
    num.sim <- nrow(Simulation)
    
    #Dim arrays for the calculation
    cube.names <- c("Period", "Date", "Time", "SpotRate", "DiscRate", "TwoYear", "TenYear")    
    sim.cube <- array(data = NA, c(num.sim, 7), dimnames = list(seq(c(1:num.sim)),cube.names))

    #Populate the simulation cube  
    sim.cube[,1] <- num.period
    sim.cube[,2] <- pmtdate
    sim.cube[,3] <- time.period
    
    #Dimension the arrays that will be needed
    oas.names <- c("OAS", "WAL", "ModDur", "YTM", "Price")
    #OAS out holds OAS solutions to individual trajectory calcualtions solving for the spread to price
    OAS.Out <- array(data = NA, c(paths,5), dimnames = list(seq(c(1:paths)),oas.names))
    
    OAS.CashFlow <- array(data = NA, c(num.sim,paths))
    OAS.DiscMatrix <- array(data = NA, c(num.sim, paths))
  
      
    for(j in 1:paths){
    
    #calculate spot rate for discounting  ([,5] multiplied by 100 for TermStructure - tried it did not work)
    #sim cube 5 ifelse synchs the CIR output to that of term strucutred for MBS cashflow analysis this needs to be fixed
    #rates should be passed through in a common scales regardless of interest rate model  
    sim.cube[,4] <- cumprod(1 + Simulation[,j])
    #sim.cube 5 is the discount rate to value cash flows
    sim.cube[,5] <- (((sim.cube[,4] ^ (1/ sim.cube[,3]))^(1/months.in.year))-1)
    
    sim.cube[,6] <- as.vector(CIRBondPrice(shortrate = as.numeric(Simulation[, j]), 
                    kappa = kappa, lambda = lambda, theta = theta, sigma = sigma, T = 2, step = 0, result = "y") * 100)
    
    sim.cube[,7] <- as.vector(CIRBondPrice(shortrate = Simulation[, j], 
                    kappa = kappa, lambda = lambda, theta = theta, sigma = sigma, T = 10, step = 0, result = "y") * 100)
      

      #Initialize OAS Term Structure object.  This object is passed to prepayment assumption
      #Allows the prepayment model to work in the Option Adjusted Spread function replacing Term Structure
      #When sigma is zero the simulated spot rates are compounded forward rates and the two and ten year
      #rates are calcualted from the calculated spot rate rate curve
    
      if (TermStructure != "TRUE")
      OAS.Term.Structure <- new("TermStructure",
                                tradedate = as.character(trade.date),
                                period = as.numeric(sim.cube[,3]),
                                date = unname(as.character(as.Date(sim.cube[,2], origin = "1970-01-01"))),
                                spotrate = as.numeric(sim.cube[,5]),
                                forwardrate = as.numeric(Simulation[,j]),
                                TwoYearFwd = as.numeric(sim.cube[,6]),
                                TenYearFwd = as.numeric(sim.cube[,7]))
    
      else
      OAS.Term.Structure <- new("TermStructure",
                                tradedate = as.character(as.Date(trade.date, "%m-%d-%Y")),
                                period = as.numeric(sim.cube[,1]),
                                date = unname(as.character(as.Date(sim.cube[,2], origin = "1970-01-01"))),
                                spotrate = as.numeric(sim.cube[,5]) * 100,
                                forwardrate = as.numeric(Simulation[,j] * 100),
                                TwoYearFwd = as.numeric(sim.cube[,6]),
                                TenYearFwd = as.numeric(sim.cube[,7]))
                
      Prepayment <- PrepaymentAssumption(bond.id = bond.id, TermStructure = OAS.Term.Structure, MortgageRate = MortgageRate, 
                           PrepaymentAssumption = "MODEL", ModelTune = ModelTune, Burnout = Burnout)
    
      MtgCashFlow <- MortgageCashFlows(bond.id = bond.id, original.bal = original.bal, settlement.date = settlement.date, 
                                     price = price, PrepaymentAssumption = Prepayment)
      
      OAS.CashFlow[,j] <- as.vector(MtgCashFlow@TotalCashFlow)
      OAS.DiscMatrix [,j] <- as.vector(sim.cube[,5])

        
    #error trapping of price is above currently line 1533 
    proceeds <- as.numeric((original.bal * factor * price/100) + MtgCashFlow@Accrued)
        
    #Solve for spread to spot curve to equal price (OAS Term Strucutre divided by 100 - tried did not work)
    OAS.Out[j,1] <- uniroot(Spot.Spread, interval = c(-1, 1), tol = .0000000001, cashflow = MtgCashFlow@TotalCashFlow,
                             discount.rates = OAS.Term.Structure@spotrate, t.period = OAS.Term.Structure@period , proceeds)$root
    OAS.Out[j,2] <- MtgCashFlow@WAL
    OAS.Out[j,3] <- MtgCashFlow@ModDuration
    OAS.Out[j,4] <- MtgCashFlow@YieldToMaturity
     
  } # end of the OAS j loop
  
    # Calculate OAS spread find the spread such that the average proceeds is equal to proceeds
      OAS <- function(spread = numeric(), DiscountMatrix = matrix(), CashFlowMatrix = matrix(), period = vector(), proceeds = numeric(), paths = numeric()) {
      OAS.Proceeds <- data.frame(((1/((1 + OAS.DiscMatrix[,] + spread)^ period)) * OAS.CashFlow[,]))
      OAS.Proceeds <- (colSums(OAS.Proceeds)/proceeds) * 100
      return(mean(OAS.Proceeds) - price)}
      
      OAS.Spread <- uniroot(OAS, interval = c(-1,1), tol = .000000001, DiscountMatrix = OAS.DiscMatrix, CashFlowMatrix = OAS.CashFlow,
                             period = OAS.Term.Structure@period, proceeds = proceeds, paths = paths)$root
  
    #Calculate OAS to price for price distribution
    OAS.Price <- function(spread = numeric(), DiscountMatrix = matrix(), CashFlowMatrix = matrix(), period = vector(), proceeds = numeric(), paths = numeric()) {
    OAS.Proceeds <- data.frame(((1/((1 + OAS.DiscMatrix[,] + spread)^ period)) * OAS.CashFlow[,]))
    OAS.Proceeds <- (colSums(OAS.Proceeds)/proceeds) * 100
    return(OAS.Proceeds)}
  
    Price.Dist <- OAS.Price(OAS.Spread, DiscountMatrix = OAS.DiscMatrix, CashFlowMatrix = OAS.CashFlow,
                            period = OAS.Term.Structure@period, proceeds = proceeds, paths = paths)
    OAS.Out[,5] <- Price.Dist 

    # Calculate static cash flow spread to the curve at zero volatility
    # Using the prepayment model this will always match the ZV spread indiciating the pricing benchmark is exact
    # In reality the spread to the curve will be based on the pricing speed used.
    # This is a good check but in reality the spread to the curve must be calculated in the PassThrough OAS and passed to 
    # ZeroVolatility Object
    if (paths == 1) {                                   
    InterpolateCurve <- loess(as.numeric(rates.data[1,2:12]) ~ as.numeric(rates.data[2,2:12]), data = data.frame(rates.data))  
    SpreadtoCurve = ((MtgCashFlow@YieldToMaturity  * 100) - predict(InterpolateCurve, MtgCashFlow@WAL ))/100
    }
  
    if (TermStructure != "TRUE")      
  
    {new("MortgageOAS",
      OAS = OAS.Spread,
      ZVSpread = mean(OAS.Out[,1]),
      SpreadToCurve = 999,
      PathSpread = OAS.Out[,1],
      PathWAL = OAS.Out[,2],
      PathModDur = OAS.Out[,3],
      PathYTM =OAS.Out[,4],
      PriceDist = OAS.Out[,5]
    )}

    else OAS.Term.Structure

  }
  
  
  #---------------------------------
  #This function is for Pass Through OAS Analysis and serves constructor for OAS Analysis
  
  PassThroughOAS <- function(bond.id = "character", trade.date = "character", settlement.date = "character", original.bal = numeric(), 
                            price = numeric(), short.rate = numeric(), sigma = numeric(), paths = numeric(), 
                            PrepaymentAssumption = "character", ..., begin.cpr = numeric(), end.cpr = numeric(), seasoning.period = numeric(), CPR = numeric()){
    
    #Error Trap Settlement Date and Trade Date order.  This is not done in the Error Trap Function because that function is 
    #to trap errors in bond information that is passed into the functions.  It is trapped here because this is the first use of trade date
    if(trade.date > settlement.date) stop ("Trade Date Must be less than settlement date")
    
    
    #Rate Delta is set to 1 (100 basis points) for effective convexity calculation                          
    Rate.Delta = .25
    
    # The first step is to read in the Bond Detail, rates, and Prepayment Model Tuning Parameters
    conn1 <-  gzfile(description = paste("~/BondLab/BondData/",bond.id, ".rds", sep = ""), open = "rb")
    bond.id = readRDS(conn1)
    
    #Call the desired curve from rates data folder
    conn2 <- gzfile(description = paste("~/BondLab/RatesData/", as.Date(trade.date, "%m-%d-%Y"), ".rds", sep = ""), open = "rb")
    rates.data <- readRDS(conn2)
    
    #Call Mortgage Rate Functions
    conn3 <- gzfile("~/BondLab/PrepaymentModel/MortgageRate.rds", open = "rb")
    MortgageRate <- readRDS(conn3)  
    
    Burnout = bond.id@Burnout
    
    #Call Prepayment Model Tuning Parameters
    conn4 <- gzfile(description = paste("~/BondLab/PrepaymentModel/", as.character(bond.id@Model), ".rds", sep =""), open = "rb")        
    ModelTune <- readRDS(conn4)

    
    #Call OAS Term Strucuture to Pass to the Prepayment Model
    TermStructure <- Mortgage.OAS(bond.id = as.character(bond.id@ID), trade.date = trade.date, settlement.date = settlement.date, original.bal = original.bal, 
                                  price = price, short.rate = short.rate, sigma = sigma, paths = 1, TermStructure = "TRUE")
    
    #Third if mortgage security call the prepayment model
    PrepaymentAssumption <- PrepaymentAssumption(bond.id = bond.id, MortgageRate = MortgageRate, 
                                                 TermStructure = TermStructure, PrepaymentAssumption = PrepaymentAssumption, ModelTune = ModelTune, Burnout = Burnout, 
                                                 begin.cpr = begin.cpr, end.cpr = end.cpr, seasoning.period = seasoning.period, CPR = CPR)
    
    #The fourth step is to call the bond cusip details and calculate Bond Yield to Maturity, Duration, Convexity and CashFlow.
    MortgageCashFlow <- MortgageCashFlows(bond.id = bond.id, original.bal = original.bal, settlement.date = settlement.date, 
                                          price = price, PrepaymentAssumption = PrepaymentAssumption)
    
    #Calculate effective duration, convexity, and key rate durations and key rate convexities
    #This is done with the MtgTermStructureFunction this creates the class BondTermStructure
    #MortgageTermStructure <- MtgTermStructure(bond.id = MortgageCashFlow, original.bal = original.bal, Rate.Delta = Rate.Delta, TermStructure = TermStructure, 
    #settlement.date = settlement.date, principal = original.bal *  MortgageCashFlow@MBSFactor, price = price, cashflow = MortgageCashFlow)
           
    MortgageOAS  <- Mortgage.OAS(bond.id = as.character(bond.id@ID), trade.date = trade.date, settlement.date = settlement.date, original.bal = original.bal, 
                   price = price, short.rate = short.rate, sigma = sigma, paths = paths, TermStructure = "FALSE")
    
    #Calculate the spread to the curve and pass to Zero Volatility                                   
    InterpolateCurve <- loess(as.numeric(rates.data[1,2:12]) ~ as.numeric(rates.data[2,2:12]), data = data.frame(rates.data))  
    SpreadtoCurve = ((MortgageCashFlow@YieldToMaturity  * 100) - predict(InterpolateCurve, MortgageCashFlow@WAL ))/100
    
    MortgageOAS@SpreadToCurve <- SpreadtoCurve  
      
    new("PassThroughOAS", bond.id, MortgageCashFlow, MortgageOAS)
    
  }
   


  #-----------------------
  # Classes these are the new classes used by by Bond Lab
  #------------------------

  


  
  setClass("MortgageOAS",
           representation(
             OAS = "numeric",
             ZVSpread = "numeric",
             SpreadToCurve = "numeric",
             PriceDist = "vector",
             PathSpread = "vector",
             PathWAL = "vector",
             PathModDur = "vector",
             PathYTM = "vector")
           #contains = "MBSDetails"
           )
  
# --- The following classes define rates and Prepayment model tune classes
# --- these classes are used to pass term strucuture information and prepayment model
# --- tuning paramaters  
  
# ----- The following classes define rate of return and valuation classes

  

        
  setClass("RateofReturn",
         representation(
         PmtDate = "character",
         Period = "numeric",
         ReinvestmentRate = "numeric",
         ReceivedCF = "numeric",
         ReInvestmentIncome = "numeric",
         RemainingCF = "numeric",
         HorizonSpread = "numeric"))



  #------ The classes MortgageCashFlows and Mortgage TermStructure extends the MortgageAnalytics a single storage class 
  #------ for all mortgage passthrough analytics

  #setClass("PassThroughAnalytics", 
  #         contains = c("MBSDetails", "MortgageCashFlows", "MortgageTermStructure", "TermStructure", "PrepaymentAssumption", "Mtg.ScenarioSet"))
  
  setClass("PassThroughOAS",
           representation())


#---------------------------------------
# Bond Lab Initialize Set Generics
#---------------------------------------



  
  setGeneric("RateofReturn",
           function(ReinvestmentRate = numeric(), ReceivedCF = "character", RemainingCF = "character",
                    SpotCurve = "character", FwdCurve = "character", HorizonSpread = numeric())
             {standardGenric("RateofReturn")})



  


  
  
  
  
