{
    "contents" : "# BondLab is a software application for the analysis of \n# fixed income securities it provides a suite of applications\n# in addition to standard fixed income analysis bond lab provides \n# for the specific analysis of structured products residential mortgage backed securities, \n# asset backed securities, and commerical mortgage backed securities\n# License MIT\n\n#Copyright (C) 2014  Glenn M Schultz, CFA\n  \n  options(digits = 8)\n  library(termstrc)\n  library(ggplot2)\n  library(reshape2)\n  library(lubridate)\n  library(methods)\n  library(plyr)\n\n  #----------------------------------------------------------------------------------------\n  # Utils globalVariables is called so that the R CMD check will not issue a note\n  # The utils below are global variables for the multi plot function used for ggplot2 methods\n  utils::globalVariables(c(\"grid.newpage\", \"pushViewport\", \"viewport\", \"gridlayout\"))\n  # The utils below are global variables for the BondAnalytics and PassThroughAnalytics methods using ggplot2\n  utils::globalVariables(c(\"Period\", \"CashFlow\", \"KRTenor\", \"KRDuration\", \"Period\", \"CashFlow\"))\n  # The utils below are global variables for the MortgageCashFlow methods using ggplot2\n  utils::globalVariables(c(\"value\", \"variable\"))\n\n  #----------------------------------------------------------------------------------------\n  #Bond Lab Functions\n  #----------------------------------------------------------------------------------------\n\n  #---------------------------------\n  #Time value of money functions\n  #---------------------------------\n  \n  TimeValue <- function(interest.rate = numeric(), number.period = numeric(), frequency = numeric()){\n    if (missing(interest.rate))\n      stop(\"Need to specify interest.rate as number between 0 and 1 for calculations.\")\n    if (!is.numeric(interest.rate)  )\n      stop(\"No numeric interest.rate specified.\")\n    if (interest.rate <0 | interest.rate > 1)\n      stop(\"No valid  interest.rate specified.\")\n    \n    if(missing(number.periods))\n      stop(\"Need to provide the number of discounting periods\")\n    if(!is.numeric(number.periods))\n      stop(\" No numeric discounting period specfified\")\n    if (number.periods < 1 )\n      stop(\"No valid  number.periods specified.\")\n    \n    if(missing(frequency))\n      stop(\"Need to provide the frequency\")\n    if(!is.numeric(frequency))\n      stop(\" No numeric frequency specfified\")\n    if (frequency < 1 | frequency >12 )\n      stop(\"No valid frequency specified.\")\n    \n    interest.rate = interest.rate/frequency\n    \n  }\n\n  PresentValue <- function(interest.rate = numeric(), number.periods = numeric(), frequency = numeric()) {\n  \n  if (missing(interest.rate))\n    stop(\"Need to specify interest.rate as number between 0 and 1 for calculations.\")\n  if (!is.numeric(interest.rate)  )\n    stop(\"No numeric interest.rate specified.\")\n  if (interest.rate <0 | interest.rate > 1)\n    stop(\"No valid  interest.rate specified.\")\n  \n  if(missing(number.periods))\n    stop(\"Need to provide the number of discounting periods\")\n  if(!is.numeric(number.periods))\n    stop(\" No numeric discounting period specfified\")\n  if (number.periods < 1 )\n    stop(\"No valid  number.periods specified.\")\n  \n  if(missing(frequency))\n    stop(\"Need to provide the frequency\")\n  if(!is.numeric(frequency))\n    stop(\" No numeric frequency specfified\")\n  if (frequency < 1 | frequency >12 )\n    stop(\"No valid frequency specified.\")\n  \n  interest.rate = interest.rate/frequency\n  \n  1/(1+interest.rate)^number.periods\n  }\n\n  FutureValue <- function(interest.rate = numeric(), number.periods = numeric(), frequency = numeric()) {\n  if (missing(interest.rate))\n    stop(\"Need to specify interest.rate as number between 0 and 1 for calculations.\")\n  if (!is.numeric(interest.rate)  )\n    stop(\"No numeric interest.rate specified.\")\n  if (interest.rate <0 | interest.rate > 1)\n    stop(\"No valid  interest.rate specified.\")\n  \n  if(missing(number.periods))\n    stop(\"Need to provide the number of discounting periods\")\n  if(!is.numeric(number.periods))\n    stop(\" No numeric discounting period specfified\")\n  if (number.periods < 1 )\n    stop(\"No valid  number.periods specified.\")\n  \n  if(missing(frequency))\n    stop(\"Need to provide the frequency\")\n  if(!is.numeric(frequency))\n    stop(\" No numeric frequency specfified\")\n  if (frequency < 1 | frequency >12 )\n    stop(\"No valid frequency specified.\")\n  \n  interest.rate = interest.rate/frequency\n  \n  (1+interest.rate)^number.periods  \n  } \n\n  PresentValueAnnuity <-function(interest.rate = numeric(), number.periods = numeric(), frequency = numeric()) {\n  if (missing(interest.rate))\n    stop(\"Need to specify interest.rate as number between 0 and 1 for calculations.\")\n  if (!is.numeric(interest.rate)  )\n    stop(\"No numeric interest.rate specified.\")\n  if (interest.rate <0 | interest.rate > 1)\n    stop(\"No valid  interest.rate specified.\")\n  if(missing(number.periods))\n    stop(\"Need to provide the number of discounting periods\")\n  if(!is.numeric(number.periods))\n    stop(\" No numeric discounting period specfified\")\n  if (number.periods < 1 )\n    stop(\"No valid  number.periods specified.\")\n  if(missing(frequency))\n    stop(\"Need to provide the frequency\")\n  if(!is.numeric(frequency))\n    stop(\" No numeric frequency specfified\")\n  if (frequency < 1 | frequency >12 )\n    stop(\"No valid frequency specified.\")\n  interest.rate = interest.rate/frequency\n  ((1-(1/(1+interest.rate)^number.periods))/interest.rate)\n  }\n\n  PresentValueAnnuityDue <-function(interest.rate = numeric(), number.periods = numeric(), frequency = numeric()){\n  if (missing(interest.rate))\n    stop(\"Need to specify interest.rate as number between 0 and 1 for calculations.\")\n  if (!is.numeric(interest.rate)  )\n    stop(\"No numeric interest.rate specified.\")\n  if (interest.rate <0 | interest.rate > 1)\n    stop(\"No valid  interest.rate specified.\")\n  if(missing(number.periods))\n    stop(\"Need to provide the number of discounting periods\")\n  if(!is.numeric(number.periods))\n    stop(\" No numeric discounting period specfified\")\n  if (number.periods < 1 )\n    stop(\"No valid  number.periods specified.\")\n  if(missing(frequency))\n    stop(\"Need to provide the frequency\")\n  if(!is.numeric(frequency))\n    stop(\" No numeric frequency specfified\")\n  if (frequency < 1 | frequency >12 )\n    stop(\"No valid frequency specified.\")\n  interest.rate = interest.rate/frequency\n  ((1-(1/(1+interest.rate)^number.periods))/interest.rate) * (1+interest.rate)  \n  }\n\n  FutureValueAnnuity <- function(interest.rate = numeric(), number.periods = numeric(), frequency = numeric()){\n  if (missing(interest.rate))\n    stop(\"Need to specify interest.rate as number between 0 and 1 for calculations.\")\n  if (!is.numeric(interest.rate)  )\n    stop(\"No numeric interest.rate specified.\")\n  if (interest.rate <0 | interest.rate > 1)\n    stop(\"No valid  interest.rate specified.\")\n  \n  if(missing(number.periods))\n    stop(\"Need to provide the number of discounting periods\")\n  if(!is.numeric(number.periods))\n    stop(\" No numeric discounting period specfified\")\n  if (number.periods < 1 )\n    stop(\"No valid  number.periods specified.\")\n  \n  if(missing(frequency))\n    stop(\"Need to provide the frequency\")\n  if(!is.numeric(frequency))\n    stop(\" No numeric frequency specfified\")\n  if (frequency < 1 | frequency >12 )\n    stop(\"No valid frequency specified.\")\n  \n  interest.rate = interest.rate/frequency\n  (((1 + interest.rate)^(number.periods)) -1)/interest.rate\n  }\n\n  #----------------------------------\n  # Bond Yield to Maturity Functions\n  #---------------------------------\n\n  #YYTMtoPrice is a simple yield to price equation for a standard bond\n  #This equation treats the bond as a annuity and zero coupon payment\n  YTMtoPrice<- function(yield.to.maturity = numeric() ,coupon = numeric(), coupon.frequency = numeric(), \n                        years.mat = numeric(), face.value = numeric()){\n    \n    if (missing(yield.to.maturity))\n    stop(\"Need to specify a maturity greater than 0\")\n    if (!is.numeric(yield.to.maturity)  )\n    stop(\"No numeric yield to maturity specified.\")\n    if (yield.to.maturity <0 | yield.to.maturity > 1)\n    stop(\"No valid  interest.rate specified.\")\n  \n  #need to error trap this function\n  n = years.mat * coupon.frequency\n  c = coupon/coupon.frequency\n  i = yield.to.maturity/coupon.frequency\n  fv = face.value\n  \n  (((1-(1/(1+i)^n))/i) * (fv * c)) + (1/(1+i)^n * fv)   \n  }\n\n  #bondprice is a simple price to yield equation for a standard bond\n  #This equation treats the bond as a annuity and zero coupon payment\n  bondprice<- function(yield.to.maturity = numeric(),coupon = numeric(), coupon.frequency = numeric(), years.mat = numeric(), face.value = numeric()){\n  n = years.mat * coupon.frequency\n  c = coupon/coupon.frequency\n  i = yield.to.maturity/coupon.frequency\n  fv = face.value\n  \n  (((1-(1/(1+i)^n))/i) * (fv * c)) + (1/(1+i)^n * fv)\n  }\n\n  #bond estimated yield to maturity this equation estimates a bond's yield\n  #to maturity for a yield to maturity guess may be used with uniroot ytm functions\n  EstimYTM <- function(coupon = numeric(), coupon.frequency = numeric(), years.mat = numeric(), face.value = numeric(), price = numeric()){\n  c = coupon\n  n = years.mat\n  f = coupon.frequency\n  fv = face.value\n  p = price/100 \n  ((c * fv) + ((fv - (fv *p))/2)) / (((fv + (fv *p))/f))\n  }\n\n  #---------------------------\n  # Mortgage Payment Functions\n  #---------------------------\n\n  Mortgage.Monthly.Payment <- function(orig.bal = numeric(), note.rate = numeric(), term.mos = numeric()){\n  \n  #Error Trap Note Rate\n    if (missing(note.rate))\n      stop(\"Need to specify interest.rate as number between 0 and 1 for calculations.\")\n    if (!is.numeric(note.rate)  )\n      stop(\"No numeric interest.rate specified.\")\n\n  note.rate = note.rate/12 \n  term = term.mos\n  pmt.factor = (1+note.rate)^term\n  pmt = (orig.bal * pmt.factor) * (note.rate/(pmt.factor -1))\n  pmt\n  }\n\n  Sched.Prin <- function(balance = numeric(), note.rate = numeric(), term.mos = numeric(), period = numeric()){\n  note.rate = note.rate/12\n  term = term.mos\n  disc.pmt =  note.rate * (1+note.rate)^(period-1)\n  disc.prin = ((1+note.rate)^(term))-1\n  Scheduled.Prin = balance *(disc.pmt/disc.prin)\n  Scheduled.Prin\n  }\n\n  Remain.Balance <- function(balance = numeric(), note.rate = numeric(), term.mos = numeric(), period = numeric()){\n  note.rate = note.rate/1200\n  term = term.mos\n  Remain.Balance = balance * ((((1+note.rate)^term) - ((1+note.rate)^period))/(((1+note.rate)^term.mos)-1))\n  Remain.Balance\n  }\n\n  PPC.Ramp <- function(season.period = numeric(), begin.cpr = numeric(), end.cpr = numeric(), period = numeric()){\n  if(end.cpr >= 1) {end.cpr = end.cpr/100 \n                    begin.cpr = begin.cpr/100}\n  monthly.cpr = (begin.cpr + ((period - 1) * (end.cpr-begin.cpr)/(season.period -1)))\n  cpr = ifelse(monthly.cpr <= end.cpr, monthly.cpr, end.cpr)\n  cpr\n  }\n  \n  SMMVector.To.CPR <- function(SMM = vector(), num.period = numeric()){\n    SMM = prod(1 + SMM)^(1/num.period)\n    SMM = SMM - 1\n    SMMVector.to.CPR = 1-(1-SMM)^12 \n  }\n\n  #--------------------------\n  # Error trap function for bond inputs\n  #--------------------------  \n  ErrorTrap <- function(bond.id = \"character\", principal = numeric(), settlement.date = \"character\", price = numeric()) {\n  #Error inputs by the user make sure all needed dates and values are passed to Bond Cash Flow\n  issue.date = bond.id@IssueDate\n  start.date = bond.id@DatedDate\n  end.date = bond.id@Maturity\n  lastpmt.date = bond.id@LastPmtDate\n  nextpmt.date = bond.id@NextPmtDate\n  coupon = bond.id@Coupon\n  frequency = bond.id@Frequency\n  \n  # Test Bond Inputs\n  if(missing(issue.date)) stop(\"missing issue date\")\n  if(missing(start.date)) stop(\"missing start date\")\n  if(missing (end.date)) stop(\"missing end (Maturity) date\")\n  if(missing(lastpmt.date)) stop(\"missing last payment date\")\n  if(missing (nextpmt.date)) stop(\"missing next payment date\")\n  if(missing (coupon)) stop(\"missing coupon\")\n  if(missing (frequency)) stop(\"missing frequency\")\n  #Test Trade Inputs\n  if (missing (settlement.date)) stop(\"missing settlement date\")\n  if(missing (principal)) stop(\"missing principal\")\n  if(missing (price)) stop(\"missing price\")\n  \n  issue.date = as.Date(c(issue.date), \"%m-%d-%Y\")\n  start.date = as.Date(c(start.date), \"%m-%d-%Y\")\n  end.date = as.Date(c(end.date), \"%m-%d-%Y\")\n  settlement.date = as.Date(c(settlement.date), \"%m-%d-%Y\")\n  lastpmt.date = as.Date(c(lastpmt.date), \"%m-%d-%Y\")\n  nextpmt.date = as.Date(c(nextpmt.date), \"%m-%d-%Y\")\n  \n  #============= Pass dates into the function m-d-y ======================\n  \n  #Error Trapping on Dates settlement date < next payment date or settlement date , issue date    \n  if(settlement.date > nextpmt.date) stop (\"Settlement Date is Greater Than Next Payment Date\")\n  if(settlement.date < issue.date) stop (\"Settlement Date is Less Than Issue Date\")\n  if(settlement.date < lastpmt.date) stop (\"Settlment Date is Less Than Last Payment Date\")\n  #Error Trapping on frequency and payment dates\n  \n  #Error Trap the user's price input\n  if(price <= 0) stop(\"No valid bond price\")\n  #Error Trap the user's coupon input\n  if (coupon < 0 | coupon > 100) stop(\"No valid coupon specified.\")\n  #Note: Minimum demonination needs to be added to class bond information as well as function input\n  }\n\n  #----------------------------\n  #Bond basis function This function set the interest payment day count basis  \n  #----------------------------\n\n  BondBasisConversion <- function(issue.date, start.date, end.date, settlement.date, \n                        lastpmt.date, nextpmt.date){\n  # This  Function converts day count to bond U.S. Bond Basis 30/360 day count calculation \n  #It returns the number of payments that will be received, period, and n for discounting\n  #issue.date is the issuance date of the bond\n  #start.date is the dated date of the bond\n  #end.date is the maturity date of the bond\n  #settlement.date is the settlement date of hte bond\n  #lastpmt.date is the last coupon payment date\n  #nextpmt.date is the next coupon payment date\n\n  d1 = if(settlement.date == issue.date) {day(issue.date)} else {day(settlement.date)}    \n  m1 = if(settlement.date == issue.date) {month(issue.date)} else {month(settlement.date)}\n  y1 = if(settlement.date == issue.date) {year(issue.date)} else {year(settlement.date)}\n  d2 = day(nextpmt.date)\n  m2 = month(nextpmt.date)\n  y2 = year(nextpmt.date)\n  \n  (max(0, 30 - d1) + min(30, d2) + 360*(y2-y1) + 30*(m2-m1-1))/360}\n\n  #--------------------------\n  #Bond cash flow function. This function computes the cash flow of a standard non-callable bond\n  #-------------------------\n  BondCashFlows <- function (bond.id = \"character\", principal = numeric(), settlement.date = \"character\", price = numeric()){\n  \n  issue.date = as.Date(bond.id@IssueDate, \"%m-%d-%Y\")\n  start.date = as.Date(bond.id@DatedDate, \"%m-%d-%Y\")\n  end.date = as.Date(bond.id@Maturity, \"%m-%d-%Y\")\n  lastpmt.date = as.Date(bond.id@LastPmtDate, \"%m-%d-%Y\")\n  nextpmt.date = as.Date(bond.id@NextPmtDate, \"%m-%d-%Y\")\n  coupon = bond.id@Coupon\n  frequency = bond.id@Frequency       \n  settlement.date = as.Date(c(settlement.date), \"%m-%d-%Y\")\n  \n  # This function error traps bond input information\n  ErrorTrap(bond.id = bond.id, principal = principal, settlement.date = settlement.date, price = price)\n  \n  #  Validate the price and coupon passed through the error trapping function\n  #  This validates that the correct unit is passed into the Bond Cash Flow function\n  if(price <= 1) {price = price} else {price = price/100}\n  if(coupon > 1) {coupon = coupon/100} else {coupon = coupon}\n  \n  #Calculate the number of cashflows that will be paid from settlement date to maturity date \n  #step1 calculate the years to maturity  \n  ncashflows = BondBasisConversion(issue.date = issue.date, start.date = start.date, end.date = end.date, settlement.date = settlement.date,\n                                   lastpmt.date = lastpmt.date, nextpmt.date = end.date) \n  \n  #Step2 build a vector of dates for the payment schedule\n  # first get the pmtdate interval\n  pmtdate.interval = 12/frequency\n  # then compute the payment dates\n  pmtdate = as.Date(c(if(settlement.date == issue.date) {seq(start.date, end.date, by = paste(pmtdate.interval, \"months\"))} \n                      else {seq(nextpmt.date, end.date, by = paste(pmtdate.interval, \"months\"))}), \"%m-%d-%Y\")\n  \n  #step3 build the time period vector (n) for discounting the cashflows nextpmt date is vector of payment dates to n for each period\n  time.period = BondBasisConversion(issue.date = issue.date, start.date = start.date, end.date = end.date, settlement.date = settlement.date,\n                                    lastpmt.date = lastpmt.date, nextpmt.date = pmtdate)\n  \n  #step4 Count the number of cashflows \n  #num.periods is the total number of cashflows to be received\n  #num.period is the period in which the cashflow is received\n  num.periods = length(time.period)\n  col.names <- c(\"Period\", \"Date\", \"Time\", \"Principal Outstanding\", \"Coupon\", \"Coupon Income\", \"Principal Paid\", \"TotalCashFlow\",\n                 \"Present Value Factor\", \"Present Value\", \"Duration\", \"Convexity Time\", \"CashFlow Convexity\", \"Convexity\")\n  \n  Bond.CF.Table <- array(data = NA, c(num.periods, 14), dimnames = list(seq(c(1:num.periods)),col.names))  \n  for(i in 1:num.periods){\n    Bond.CF.Table[i,1] = i\n    Bond.CF.Table[i,2] = pmtdate[i]\n    Bond.CF.Table[i,3] = time.period[i]\n    Bond.CF.Table[i,4] = principal\n    Bond.CF.Table[i,5] = coupon /frequency\n    Bond.CF.Table[i,6] = Bond.CF.Table[i,5] * Bond.CF.Table[i,4]\n    if(Bond.CF.Table[i,2] == end.date) {Bond.CF.Table[i,7] = principal} else {Bond.CF.Table[i,7] = 0}\n    Bond.CF.Table[i,8] = Bond.CF.Table[i,6] + Bond.CF.Table[i,7]\n  }\n  \n  #step5 calculate accrued interest for the period\n  days.to.nextpmt = (BondBasisConversion(issue.date = issue.date, start.date = start.date, end.date = end.date, \n                          settlement.date = settlement.date, lastpmt.date = lastpmt.date, nextpmt.date = nextpmt.date)) * 360\n  \n  days.between.pmtdate = ((12/frequency)/12) * 360\n  days.of.accrued = days.between.pmtdate - days.to.nextpmt\n  accrued.interest = (days.of.accrued/days.between.pmtdate) * Bond.CF.Table[1,6]\n  \n  #Step6 solve for yield to maturity given the price of the bond.  irr is an internal function used to solve for yield to maturity\n  #it is internal so that the bond's yield to maturity is not passed to a global variable that may inadvertantly use the value \n  irr <- function(rate , time.period , cashflow , principal , price , accrued.interest){\n    pv = cashflow * 1/(1+rate) ^ time.period\n    proceeds = principal * price\n    sum(pv) - (proceeds + accrued.interest)}\n  ytm = uniroot(irr, interval = c(lower = -1, upper = 1), tol =.000000001, time.period = Bond.CF.Table[,3], \n                cashflow = Bond.CF.Table[,8], principal = principal, price = price, accrued.interest = accrued.interest)$root\n  Yield.To.Maturity = (((1 + ytm)^(1/frequency))-1) * frequency\n  \n  #Step7 Present value of the cash flows Present Value Factors\n  Bond.CF.Table[,9] = 1/((1+(Yield.To.Maturity/frequency))^(Bond.CF.Table[,3] * frequency))\n  \n  #Present Value of the cash flows\n  Bond.CF.Table[,10] = Bond.CF.Table[,8] * Bond.CF.Table[,9]\n  \n  #Step8 Risk measures Duration Factors\n  Bond.CF.Table[,11] = Bond.CF.Table[,3] * (Bond.CF.Table[,10]/((principal * price) + accrued.interest))\n  \n  #Convexity Factors\n  Bond.CF.Table[,12] = Bond.CF.Table[,3] *(Bond.CF.Table[,3] + 1)\n  Bond.CF.Table[,13] = (Bond.CF.Table[,8]/((1 + ((Yield.To.Maturity)/frequency)) ^ ((Bond.CF.Table[,3] + 2) * frequency)))/((principal * price) + accrued.interest)\n  Bond.CF.Table[,14] = Bond.CF.Table[,12] * Bond.CF.Table[,13] \n  \n  #Weighted Average Life\n  WAL = sum((Bond.CF.Table[,7] * Bond.CF.Table[,3]))/sum(Bond.CF.Table[,7])\n  #Duration and Convexity\n  Duration = apply(Bond.CF.Table, 2, sum)[11]\n  Modified.Duration = Duration/(1 + (Yield.To.Maturity/frequency))\n  Convexity = apply(Bond.CF.Table, 2, sum)[14] * .5\n  \n  #Assign Values to the slots\n  new(\"BondCashFlows\",   \n      Price = price * 100,\n      Accrued = accrued.interest,\n      YieldToMaturity = Yield.To.Maturity,\n      WAL = WAL,\n      ModDuration = Modified.Duration,\n      Convexity = Convexity,\n      Period = Bond.CF.Table[,1],\n      PmtDate = as.character(as.Date(Bond.CF.Table[,2], origin = \"1970-01-01\")),\n      TimePeriod = Bond.CF.Table[,3],\n      PrincipalOutstanding  = Bond.CF.Table[,4],\n      CouponPmt = Bond.CF.Table[,5],\n      TotalCashFlow = Bond.CF.Table[,8],\n      bond.id\n  )\n  }\n  #------------------------------------------------------\n  #Mortgage cash flow function.  This function calculates the cash flow of a mortgage pass through security\n  #-----------------------------------------------------\n  MortgageCashFlows <- function(bond.id = \"character\", original.bal = numeric(), settlement.date = \"character\", \n                              price = numeric(), PrepaymentAssumption = \"character\"){\n   \n  #This function error traps mortgage bond inputs\n  ErrorTrap(bond.id = bond.id, principal = original.balance, settlement.date = settlement.date, price = price)\n  \n  \n  issue.date = as.Date(bond.id@IssueDate, \"%m-%d-%Y\")\n  start.date = as.Date(bond.id@DatedDate, \"%m-%d-%Y\")\n  end.date = as.Date(bond.id@Maturity, \"%m-%d-%Y\")\n  lastpmt.date = as.Date(bond.id@LastPmtDate, \"%m-%d-%Y\")\n  nextpmt.date = as.Date(bond.id@NextPmtDate, \"%m-%d-%Y\")\n  coupon = bond.id@Coupon\n  frequency = bond.id@Frequency\n  delay = bond.id@PaymentDelay\n  settlement.date = as.Date(c(settlement.date), \"%m-%d-%Y\")\n  \n  #Mortgage specific inputs\n  note.rate = bond.id@GWac\n  FirstPmtDate = bond.id@FirstPmtDate\n  FinalPmtDate = bond.id@FinalPmtDate\n  servicing.fee = bond.id@Servicing\n  pmi = bond.id@PMI\n  g.fee = bond.id@Gfee\n  \n  #error trap function needs to be upated to reflect expansion of the bond class\n  #needs servicing, pmi and gfee error trapping\n  \n  #  Validate the price and coupon passed through the error trapping function\n  #  This validates that the correct unit is passed into the Bond Cash Flow function\n  if(price <= 1) {price = price} else {price = price/100}\n  if(coupon > 1) {coupon = coupon/100} else {coupon = coupon}\n  if(note.rate > 1) {note.rate = note.rate/100} else {note.rate = note.rate}\n  \n  #calcualte beginning balance (principal) from the MBS pool factor\n  factor = bond.id@MBSFactor\n  principal = original.bal * factor\n  \n  #Calculate the number of cashflows that will be paid from settlement date to the last pmt date\n  #step 1 calculate the years to maturity\n  ncashflows = BondBasisConversion(issue.date = issue.date, start.date = start.date, end.date = end.date, settlement.date = settlement.date,\n                                   lastpmt.date = lastpmt.date, nextpmt.date = end.date) \n  \n  #Step2 build a vector of dates for the payment schedule\n  # first get the pmtdate interval\n  pmtdate.interval = 12/frequency\n  # then compute the payment dates\n  pmtdate = as.Date(c(if(settlement.date == issue.date) {seq(start.date, end.date, by = paste(pmtdate.interval, \"months\"))} \n                      else {seq(nextpmt.date, end.date, by = paste(pmtdate.interval, \"months\"))}), \"%m-%d-%Y\")\n  \n  #step3 build the time period vector (n) for discounting the cashflows nextpmt date is vector of payment dates to n for each period\n  time.period = BondBasisConversion(issue.date = issue.date, start.date = start.date, end.date = end.date, settlement.date = settlement.date,\n                                    lastpmt.date = lastpmt.date, nextpmt.date = pmtdate)\n  \n  #step4 Count the number of cashflows \n  #num.periods is the total number of cashflows to be received\n  #num.period is the period in which the cashflow is received\n  num.periods = length(time.period)\n  \n  #step5 initialize the prepayment model assumption class\n  \n  col.names <- c(\"Period\", \"Date\", \"Time\", \"Begin Bal\", \"Monthly Pmt\", \"Scheduled Int\", \"Scheduled Prin\", \"Prepaid Prin\", \n                 \"Ending Bal\", \"Sevicing\", \"PMI\", \"GFee\", \"Pass Through Interest\", \"Investor CashFlow\", \"Present Value Factor\", \"Present Value\", \n                 \"Duration\", \"Convexity Time\", \"CashFlow Convexity\", \"Convexity\")\n  \n  \n  MBS.CF.Table <- array(data = NA, c(num.periods, 20), dimnames = list(seq(c(1:num.periods)),col.names))  \n  for(x in 1:num.periods){\n    MBS.CF.Table[x,1] = x\n    MBS.CF.Table[x,2] = pmtdate[x] + delay\n    MBS.CF.Table[x,3] = time.period[x]\n    if (MBS.CF.Table[x,1] == 1) {MBS.CF.Table[x,4] = principal} else {MBS.CF.Table[x,4] = MBS.CF.Table[x-1,9]}\n    MBS.CF.Table[x,5] = Mortgage.Monthly.Payment(orig.bal = MBS.CF.Table[x,4], note.rate = note.rate, \n                                                 term.mos = (num.periods - MBS.CF.Table[x,1] + 1))\n    \n    MBS.CF.Table[x,6] = MBS.CF.Table[x,4] * (note.rate/12)\n    MBS.CF.Table[x,7] = Sched.Prin(balance = MBS.CF.Table[x,4], note.rate = note.rate, \n                                   term.mos = (num.periods - MBS.CF.Table[x,1] + 1), period = 1)\n        \n    if(x != num.periods) {MBS.CF.Table[x,8] = PrepaymentAssumption@SMM[x] * (MBS.CF.Table[x,4] - MBS.CF.Table[x,7])} else                     \n      {MBS.CF.Table[x,8] = 0}\n    \n    MBS.CF.Table[x,9] = MBS.CF.Table[x,4] - MBS.CF.Table[x,7] - MBS.CF.Table[x,8]\n    MBS.CF.Table[x,10] = MBS.CF.Table[x,4] * (servicing.fee/1200)\n    MBS.CF.Table[x,11] = MBS.CF.Table[x,4] * (pmi/1200)\n    MBS.CF.Table[x,12] = MBS.CF.Table[x,4] * (g.fee/1200)\n    MBS.CF.Table[x,13] = MBS.CF.Table[x,4] * (coupon/12)\n    MBS.CF.Table[x,14] = MBS.CF.Table[x,13] + MBS.CF.Table[x,7] + MBS.CF.Table[x,8]\n  }\n  \n  #step5 calculate accrued interest for the period\n  days.to.nextpmt = (BondBasisConversion(issue.date = issue.date, start.date = start.date, end.date = end.date, \n                        settlement.date = settlement.date, lastpmt.date = lastpmt.date, nextpmt.date = nextpmt.date)) * 360\n \n  days.between.pmtdate = ((12/frequency)/12) * 360\n  days.of.accrued = (days.between.pmtdate - days.to.nextpmt) \n  accrued.interest = (days.of.accrued/days.between.pmtdate) * MBS.CF.Table[1,13]\n  \n  #Step6 solve for yield to maturity given the price of the bond.  irr is an internal function used to solve for yield to maturity\n  #it is internal so that the bond's yield to maturity is not passed to a global variable that may inadvertantly use the value \n  irr <- function(rate , time.period , cashflow , principal , price , accrued.interest){\n    pv = cashflow * 1/(1+rate) ^ time.period\n    proceeds = principal * price\n    sum(pv) - (proceeds + accrued.interest)}\n  \n  ytm = uniroot(irr, interval = c(lower = -1, upper = 1), tol =.000000001, time.period = MBS.CF.Table[,3], \n                cashflow = MBS.CF.Table[,14], principal = principal, price = price, accrued.interest = accrued.interest)$root\n  \n  Yield.To.Maturity = (((1 + ytm)^(1/frequency))-1) * frequency\n  \n  #Step7 Present value of the cash flows Present Value Factors\n  MBS.CF.Table[,15] = 1/((1+(Yield.To.Maturity/frequency))^(MBS.CF.Table[,3] * frequency))\n  \n  #Present Value of the cash flows\n  MBS.CF.Table[,16] = MBS.CF.Table[,14] * MBS.CF.Table[,15]\n  \n  #Step8 Risk measures Duration Factors\n  MBS.CF.Table[,17] = MBS.CF.Table[,3] * (MBS.CF.Table[,16]/((principal * price) + accrued.interest))\n  \n  #Convexity Factors\n  MBS.CF.Table[,18] = MBS.CF.Table[,3] *(MBS.CF.Table[,3] + 1)\n  MBS.CF.Table[,19] = (MBS.CF.Table[,14]/((1 + ((Yield.To.Maturity)/frequency)) ^ ((MBS.CF.Table[,3] + 2) * frequency)))/ \n    ((principal * price) + accrued.interest)\n  MBS.CF.Table[,20] = MBS.CF.Table[,18] * MBS.CF.Table[,19] \n  \n  #Weighted Average Life\n  WAL = sum((((MBS.CF.Table[,7]) + (MBS.CF.Table[,8])) * MBS.CF.Table[,3])/ sum((MBS.CF.Table[,7]) + (MBS.CF.Table[,8])))\n  \n  #Duration and Convexity\n  Duration = apply(MBS.CF.Table, 2, sum)[17]\n  Modified.Duration = Duration/(1 + (Yield.To.Maturity/frequency))\n  Convexity = apply(MBS.CF.Table, 2, sum)[20] * .5\n  \n  #Create Class Mortgage Loan Cashflows\n  new(\"MortgageCashFlows\",\n      bond.id,\n      Price = price * 100,\n      Accrued = accrued.interest,\n      YieldToMaturity = Yield.To.Maturity,\n      WAL = WAL,\n      ModDuration = Modified.Duration,\n      Convexity = Convexity,\n      Period = MBS.CF.Table[,1],\n      PmtDate = as.character(as.Date(MBS.CF.Table[,2], origin = \"1970-01-01\")),\n      TimePeriod = MBS.CF.Table[,3],\n      BeginningBal = MBS.CF.Table[,4],\n      MonthlyPmt = MBS.CF.Table[,5],\n      MonthlyInterest = MBS.CF.Table[,6],\n      PassThroughInterest = MBS.CF.Table[,13],\n      ScheduledPrin = MBS.CF.Table[,7],\n      PrepaidPrin = MBS.CF.Table[,8],\n      EndingBal = MBS.CF.Table[,9],\n      ServicingIncome = MBS.CF.Table[,10],\n      PMIPremium = MBS.CF.Table[,11],    \n      GFeePremium = MBS.CF.Table[,12],\n      TotalCashFlow = MBS.CF.Table[,14]\n  )\n  }  \n  #-------------------------------------\n  #Risk measures.  These functions measure effective duration, effective convexity, and key rate duration\n  #These need to be fixed!!\n  #-------------------------------------\n  Effective.Duration <- function(Rate.Delta, cashflow, discount.rates, discount.rates.up, discount.rates.dwn, t.period, proceeds){\n  Price = proceeds/10\n  Price.NC = sum((1/((1+discount.rates)^t.period)) * cashflow)\n  Price.UP = sum((1/((1+discount.rates.up)^t.period)) * cashflow)\n  Price.DWN = sum((1/((1+discount.rates.dwn)^t.period)) * cashflow)  \n  (Price.UP - Price.DWN)/(2*Price*Rate.Delta)\n  }\n\n  Effective.Convexity <- function(Rate.Delta, cashflow, discount.rates, discount.rates.up, discount.rates.dwn, t.period, proceeds){\n  Price = proceeds/10\n  Price.NC = sum((1/((1+discount.rates)^t.period)) * cashflow)\n  Price.UP = sum((1/((1+discount.rates.up)^t.period)) * cashflow)\n  Price.DWN = sum((1/((1+discount.rates.dwn)^t.period)) * cashflow)\n  \n  (Price.UP + Price.DWN + (2*Price))/(2*(Price*Rate.Delta)^2)\n  }  \n\n  #-----------------------------------\n  #Bond Term Structure measures key rate duration and spot spread of a standard non callable bond\n  # and mortgage cash flow security   \n  #-----------------------------------    \n  BondTermStructure <- function(bond.id = \"character\", Rate.Delta = numeric(), TermStructure = \"character\", principal = numeric(), price = numeric(), cashflow = \"character\"){\n  \n  #Call the bond frequency to adjust the spot spread to the payment frequency of the bond\n  frequency = bond.id@Frequency\n  maturity = bond.id@Maturity\n  accrued = cashflow@Accrued\n  \n  #Class name variable.  This will set the class name for the new class to be initilized\n  ClassName <- if(bond.id@BondType != \"MBS\") {as.character(\"BondTermStructure\")} else {as.character(\"MortgageTermStructure\")}\n  \n  #Error Trap the user's price input\n  if(price <= 1) {price = price} else {price = price/100}\n  if(price <=0) stop(\"No valid bond price\")\n  proceeds = (principal * price) + accrued \n  \n  #========== Set the functions that will be used ==========\n  # These functions are set as internal functions to key rates\n  # this insures that stored values will not be wrongly be passed to the funtion\n  #internal functions used to compute key rate duration and convexity\n  Effective.Duration <- function(rate.delta, cashflow, discount.rates, \n                                 discount.rates.up, discount.rates.dwn, t.period, proceeds){\n    Price.NC = sum((1/((1+discount.rates)^t.period)) * cashflow)\n    Price.UP = sum((1/((1+discount.rates.up)^t.period)) * cashflow)\n    Price.DWN = sum((1/((1+discount.rates.dwn)^t.period)) * cashflow)\n    (Price.UP - Price.DWN)/(2*proceeds*rate.delta)\n  }\n  Effective.Convexity <- function(rate.delta, cashflow, discount.rates, \n                                  discount.rates.up, discount.rates.dwn, t.period, proceeds){\n    Price.NC = sum((1/((1+discount.rates)^t.period)) * cashflow)\n    Price.UP = sum((1/((1+discount.rates.up)^t.period)) * cashflow)\n    Price.DWN = sum((1/((1+discount.rates.dwn)^t.period)) * cashflow)\n    (Price.UP + Price.DWN - (2*proceeds))/(2*proceeds *(rate.delta^2))\n  }\n  \n  #The spot spread function is used to solve for the spread to the spot curve to normalize discounting\n  Spot.Spread <- function(spread, cashflow, discount.rates, t.period, proceeds){\n    Present.Value <- sum((1/(1+(discount.rates + spread))^t.period) * cashflow)\n    proceeds - Present.Value\n  }\n  \n  #================= set up the index names for each array that will be used in the function\n  # Index names set names for columns in the KRIndex. This table set the control strucutre for \n  # the loop that will compute key rate duration given rates in the key rate table\n  Index.Names <- c(\"Period\", \"Time\", \"Spot Curve\", \"Disc Curve\", \"KRDwn\", \"KRUp\")\n  \n  # KR.Duration.Col set the column names for the table that hold the key rate results\n  # this table will output to class bond analytics slot KRTenor and KRDuration\n  KR.Duration.Col <- c(\"Key Rate\", \"Key Rate Duration\", \"Key Rate Convexity\")\n  \n  #sets the tenor of the key rate that will report a duration\n  KR.Duration.Row <- c(\"0.25\", \"1\", \"2\", \"3\", \"5\", \"7\", \"10\", \"15\", \"20\", \"25\", \"30\")\n  \n  #set the arrays for key rate duration calculation\n  #key rate table holds data for the term structure and shifts in the key rates\n  Key.Rate.Table <- array(data = NA, c(360,6), dimnames = list(seq(c(1:360)), Index.Names))\n  \n  #key rate duration array holds the key rates and the key rate duration\n  KR.Duration <- array(data = NA, c(11,3), dimnames = list(seq(c(1:11)), KR.Duration.Col))\n  KR.Duration[,1] <- as.numeric(KR.Duration.Row)\n  \n  # Create Index for Key Rate Table for interpolation of Key Rate Duration set outer knot points\n  # the outer points are the first and last elements in KR string\n  # this needs some logic to change the right knot point if the maturity or last payment of the \n  # bond is greater than 30-years should be adaptive\n  KR <- c(\"0.083\", \"0.25\", \"1\", \"2\", \"3\", \"5\", \"7\", \"10\", \"15\", \"20\", \"25\", \"30\", \"30\")   # Key Rates\n  KRCount = length(KR)\n  KRIndex <- array(data = NA, c(KRCount, 6), dimnames = list(seq(c(1:KRCount)), Index.Names))\n  \n  # Initialize the cash flow array for discounting and key rate caclulations\n  # this will be populated from class BondCashFlows \n  CashFlowArray <- array(data = NA, c(360,2), dimnames = list(seq(1:360), c(\"period\", \"cashflow\")))\n  \n  #Initialze the spot rate array for key rate duration calculations\n  SpotRate <- as.matrix(TermStructure@spotrate)\n  \n  # Populate Period, Time(t) and Spot Rate Curve of Key Rate Table using NS coefficients from Term Stucture\n  # and then populate and align the cashflow array for discounting and key rate computations\n  for(x in 1:360){\n    \n    #Period (n) in which the cashflow is received\n    Key.Rate.Table[x,1] = x\n    \n    # Time (t) at which the cashflow is received\n    #Time period in which the cashflow was received for discounting\n    Key.Rate.Table [x,2] = x/12\n    \n    #spot rates for discounting\n    Key.Rate.Table[x,3] = SpotRate[x,1]/100   \n    \n    #Align Cash Flows and populated the CashFlowArray\n    #Step One: Make sure all cash flows are set to zero\n    CashFlowArray[x,1] = Key.Rate.Table[x,2]\n    CashFlowArray[x,2] = 0\n  }\n  \n  #Step Two: Initialize loop and set the cashflows in the array\n  #This loops through the time period and set the cashflows into the propery array location for\n  #discounts by indexing the cashflows to the array.  The indexing is conditional on the integer of the first period less than or equal to 1\n  \n  \n  if(as.integer(cashflow@TimePeriod[1] *12) != 1) CashFlowArray[as.integer(cashflow@TimePeriod * 12) + 1,2] = cashflow@TotalCashFlow\n  if(as.integer(cashflow@TimePeriod[1] * 12) == 1) CashFlowArray[as.integer(cashflow@TimePeriod * 12),2] = cashflow@TotalCashFlow\n  \n  #solve for spread to spot curve to equal price\n  spot.spread <- uniroot(Spot.Spread, interval = c(-1, 1), tol = .0000000001, CashFlowArray[,2],\n                         discount.rates = Key.Rate.Table[,3], t.period = Key.Rate.Table[,2] , proceeds)$root\n  \n  #convert the spot spread to the frequency of the bond\n  #spot.spread = (((1+spot.spread)^(1/frequency))-1) * frequency\n  #Step three add the spot spread to the spot curve to get the discount rates that are need for\n  #the key rate duration calculation\n  for(i in 1:360){\n    Key.Rate.Table[i,4] = Key.Rate.Table[i,3] + spot.spread                                  \n  }\n  \n  #========= Populate KRIndex Table =========================\n  # The key rate index table will serve as the control table for the looping\n  # using this table allows for incremental looping of discontinous segments of the\n  #spot rate curve and is proprietary to bondlab\n  # Step 1 populate Period (n)\n  KRIndex[1:KRCount,1] <- round(as.numeric(KR) *12,0)\n  \n  # Step 2 populate time period (t)\n  KRIndex[1:KRCount,2] <- as.numeric(KR)                    \n  \n  # Step 3 Populate Index Table with the relevant points on the spot curve\n  # this is done by looping through the key rate table and allows for term structure implementation\n  # other than Nelson Siegel (note: this capability needs to built into bondlab)\n  # the key rate index table (KRIndex) is used to populate the key rate table (KRTable)\n  for (j in 1:KRCount){                                   \n    for (i in 1:360){\n      if (Key.Rate.Table[i,1] == round(KRIndex[j,2] * 12,0)) {KRIndex[j,3] = Key.Rate.Table[i,3]} else {KRIndex[j,3] = KRIndex[j,3]}\n    }\n  }\n  \n  # Step 4 Populate KRIndex Table with the appropriate Discount Curve values from the key rate table \n  # these will be the reference points for the appropriate key rate shifts\n  for (j in 1:KRCount){                                   \n    for (i in 1:360){\n      if (Key.Rate.Table[i,1] == round(KRIndex[j,2] * 12,0)) {KRIndex[j,4] = Key.Rate.Table[i,4]} else {KRIndex[j,3] = KRIndex[j,3]}\n    }\n  }\n  \n  # Step 5 Populated KRIndex Table with KR Shifts\n  for (j in 1:KRCount){\n    KRIndex[j,5] = KRIndex[j,4] - (Rate.Delta/100)\n    KRIndex[j,6] = KRIndex[j,4] + (Rate.Delta/100)\n  }\n  \n  #===== Implement Shift of Spot Rates =======================\n  # Once the KRIndex is populated implement the shift in the spot rates using the KRIndex table as the control \n  # w is the counter of the internal knot points used to compute key rate duration it ignores the boundary knots\n  # used for interpolation at the end points.  x is the length of the array.  Currently the analysis is limited\n  # to loans (bonds) with a maximum of 30-years to maturity.  This can be made dynamic at some point in the future\n  # y is column counter used the key rate down and key rate up values\n  for (w in 2:(KRCount-1)){ \n    for (x in 1:360){\n      for(y in 5:6){\n        \n        # step 1: populate the spot curve outside the key rate shift =========\n        if(Key.Rate.Table[x,2] <= KRIndex[w-1,2] || Key.Rate.Table[x,2] >= KRIndex[w+1,2]) \n        {Key.Rate.Table[x,y] = Key.Rate.Table[x,4]} else {Key.Rate.Table[x,y] = 0}\n      }\n    }\n    \n    #===== Begin Interpolation of Spot Curve ==================================\n    # Maturity points on the spot rate curve to interpolate\n    KRx <- c(KRIndex[w-1,2], KRIndex[w,2], KRIndex[w+1,2]) \n    \n    # Spot rates that correspond to the maturity points Down and Up\n    for(z in 1:2){                                       \n      if (z == 1) \n      {KRy <- c(KRIndex[w-1,4], KRIndex[w,5], KRIndex[w+1,4])}         \n      else \n      {KRy <- c(KRIndex[w-1,4], KRIndex[w,6], KRIndex[w+1,4])}                                     \n      a = KRIndex[w-1,1]+ 1\n      b = KRIndex[w+1,1] - 1\n      for(h in a : b){\n        Key.Rate.Table[h,(z+4)] <- approx(KRx,KRy, Key.Rate.Table[h,2])$y\n      } # Loop through Key Rate Table and interpolation\n    } # Inner Loop to set interpolation points from KRIndex\n    \n    # This line sets the end points for disocunting when the 30-year is last point on the curve\n    # It is possible to set the endpoints longer using row 12 of the KRIndex but this will have to wait\n    # the cash flow table is programmed for MBS\n    if (KRIndex[w,2] == 30) {(Key.Rate.Table[x,5] = KRIndex[12,5]) & (Key.Rate.Table[x,6] = KRIndex[12,6])}   \n    \n    #============================== Calculate Key Rate Duration ============================================\n    KR.Duration[w-1,2] <- -Effective.Duration(\n      rate.delta = Rate.Delta/100, \n      cashflow = CashFlowArray[,2], \n      discount.rates = Key.Rate.Table[,4], \n      discount.rates.up = Key.Rate.Table[,6],\n      discount.rates.dwn = Key.Rate.Table[,5],\n      t.period = Key.Rate.Table[,2],\n      proceeds = proceeds\n    ) \n    KR.Duration[w-1,3] <- Effective.Convexity(\n      rate.delta = Rate.Delta/100, \n      cashflow = CashFlowArray[,2], \n      discount.rates = Key.Rate.Table[,4], \n      discount.rates.up = Key.Rate.Table[,6],\n      discount.rates.dwn = Key.Rate.Table[,5],\n      t.period = Key.Rate.Table[,2],\n      proceeds = proceeds\n    ) \n  } # Outer Loop around KRIndex\n  new(ClassName,\n      bond.id,\n      SpotSpread = spot.spread * 100,\n      EffDuration = sum(KR.Duration[,2]),\n      EffConvexity = sum(KR.Duration[,3]),\n      KeyRateTenor = KR.Duration[,1],\n      KeyRateDuration = KR.Duration[,2],\n      KeyRateConvexity = KR.Duration[,3]\n      \n  )\n  } # End the function\n\n  #---------------------------------------------------\n  #Term strucutre call term strc \n  #and holds forward and spot rates as slots to class Term Structure \n  #---------------------------------------------------\n  TermStructure <- function(rates.data = \"character\", method = \"character\"){\n  \n  #function(trade.date = \"character\", method = \"character\")  \n  #Error Trap User inputs to the function\n  if(missing(rates.data)) stop(\"missing rates data object\")  \n  \n  #Default to Nelson-Siegel\n  if(missing(method)) method = \"ns\"\n  \n  #Default to parametric\n  if(method == \"cs\") stop(\"cubic spline not implemented\")\n  \n  #Check that the user input a valid method\n  CheckMethod <- c(\"ns\", \"dl\", \"sv\", \"asv\", \"cs\")\n  if(!method %in% CheckMethod) stop (\"Invalid 'method' Value\")\n  \n  #Call the desired curve from rates data folder\n  #trade.date = as.Date(trade.date, \"%m-%d-%Y\")\n  rates.data <- rates.data\n  #rates.data = readRDS(paste(\"~/BondLab/RatesData/\", trade.date, \".rds\", sep = \"\"))\n  \n  #set the column counter to make cashflows for termstrucutre\n  ColCount <- as.numeric(ncol(rates.data))\n  Mat.Years <- as.numeric(rates.data[2,2:ColCount])\n  \n  #initialize coupon bonds S3 class\n  #This can be upgraded when bondlab has portfolio function\n  ISIN <- vector()\n  MATURITYDATE <- vector()\n  ISSUEDATE <- vector()\n  COUPONRATE <- vector()\n  PRICE <- vector()\n  ACCRUED <- vector()\n  CFISIN <- vector()\n  CF <- vector()\n  DATE <- vector()\n  CASHFLOWS  <- list(CFISIN,CF,DATE)\n  names(CASHFLOWS) <- c(\"ISIN\",\"CF\",\"DATE\")\n  TODAY <- vector()\n  data <- list()\n  TSInput <- list()\n  \n  ### Assign Values to List Items #########\n  data = NULL\n  data$ISIN <- colnames(rates.data[2:ColCount])\n  data$ISSUEDATE <- rep(rates.data[1,1],ColCount - 1)\n  data$MATURITYDATE <- as.Date(data$ISSUEDATE) %m+% years(Mat.Years)\n  data$COUPONRATE <- as.numeric(rates.data[1,2:ColCount])/100\n  data$PRICE <- rep(1000, ColCount -1)\n  data$ACCRUED <- rep(0, ColCount -1)\n  for(j in 1:(ColCount-1)){\n    Vector.Length <- as.numeric(round(difftime(data[[3]][j],\n                                               data[[2]][j],\n                                               units = c(\"weeks\"))/52.25,0))\n    Vector.Length = Vector.Length * 2 #This is frequency multiplier should be dynamic ?\n    data$CASHFLOWS$ISIN <- append(data$CASHFLOWS$ISIN, rep(data[[1]][j],Vector.Length))\n    data$CASHFLOWS$CF <- append(data$CASHFLOWS$CF,as.numeric(c(rep((data[[4]][j]/2),Vector.Length - 1) *1000, (1000+(data$COUPONRATE[j]/2)*1000))))\n    data$CASHFLOWS$DATE <- append(data$CASHFLOWS$DATE,seq(as.Date(rates.data[1,1]) %m+% months(6), as.Date(data[[3]][j]), by=\"6 months\"))\n  }\n  \n  #The Loop Ends here and the list is made\n  \n  data$TODAY <- as.Date(rates.data[1,1])\n  TSInput[[as.character(rates.data[1,1])]] <- c(data)\n  print(data$TODAY)\n  \n  #set term strucutre input (TSInput) to class couponbonds\n  class(TSInput) <- \"couponbonds\"\n  \n  \n  #Fit the term structure of interest rates\n  \n  if(method != \"cs\") {TSFit <- estim_nss(dataset = TSInput, group = as.character(rates.data[1,1]), matrange = \"all\", method = method)} else\n  {TSFit <- estim_cs(bonddata = TSInput, group = as.character(rates.data[1,1]), matrange = \"all\", rse = TRUE)}\n  \n  #Return the coefficient vector to be passed in to the spot and forward rate functions\n  #Maybe have the method choosen based on the one that gives the smallest RMSE\n  Vector <- switch(method,\n                   ns = unname(TSFit$opt_result[[1]]$par[c(\"beta0\", \"beta1\", \"beta2\", \"tau1\")]),\n                   dl = unname(TSFit$opt_result[[1]]$par[c(\"beta0\", \"beta1\", \"beta2\")]),\n                   sv = unname(TSFit$opt_result[[1]]$par[c(\"beta0\", \"beta1\", \"beta2\", \"tau1\", \"beta3\", \"tau2\")]),\n                   asv = unname(TSFit$opt_result[[1]]$par[c(\"beta0\", \"beta1\", \"beta2\", \"tau1\", \"tau2\", \"tau3\")]),\n                   #cs = need to figure this out\n  )\n  \n  #Calculate the spot rate curve for\n  period <- seq(from = 1, to = 492, by = 1)\n  date <- seq(as.Date(rates.data[1,1]) %m+% months(1), as.Date(data[[3]][j]), by=\"1 months\")\n  spot.rate.curve <- spotrates(method = method, beta = Vector, m = seq(from = 1/12, to = 492/12, by = 1/12))\n  forward.rate.curve <- forwardrates(method = method, beta = Vector, m = seq(from = 1/12, to = 492/12, by = 1/12))\n  Two.Year.Fwd <- (((1 + spot.rate.curve[seq(from = 25, to = 385, by = 1)]) ^ (period[seq(from = 25, to = 385, by = 1)]/12) /\n                  (1 + spot.rate.curve[seq(from = 1, to = 361, by = 1)]) ^ (period[seq(from = 1, to = 361, by = 1)]/12))^(1/2))-1\n  \n  Ten.Year.Fwd <- (((1 + spot.rate.curve[seq(from = 121, to = 481, by = 1)]) ^ (period[seq(from = 121, to = 481, by = 1)]/12) /\n                      (1 + spot.rate.curve[seq(from = 1, to = 361, by = 1)]) ^ (period[seq(from = 1, to = 361, by = 1)]/12))^(1/10))-1\n  \n  new(\"TermStructure\",\n      tradedate = as.character(rates.data[1,1]),\n      period = as.numeric(period),\n      date = as.character(date),\n      spotrate = spot.rate.curve,\n      forwardrate = forward.rate.curve,\n      TwoYearFwd = Two.Year.Fwd,\n      TenYearFwd = Ten.Year.Fwd\n  )\n} \n  \n  #----------------------------------\n  #Prepayment Model Functions.  These functions are used to build the base prepayment model\n  #----------------------------------\n  \n  #----------------------------------\n  # Seasoning function is a 3-parameter asymtote exponential function where\n  # The three parameter asymptote is equivalent to the PPC ramp\n  # a is the asymptote of the function\n  # b is the intercept of the function\n  # c is the point where the max CPR is achieved\n  \n  Seasoning <- function(alpha = numeric(), beta = numeric(), theta = numeric(), LoanAge = numeric()){\n    if (missing(alpha))\n      stop(\"Need to specify alpha tuning parameter.\")\n    if (!is.numeric(alpha)  )\n      stop(\"No numeric alpha specified.\")\n    \n    if (missing(beta))\n      stop(\"Need to specify beta tuning parameter.\")\n    if (!is.numeric(beta)  )\n      stop(\"No numeric beta specified.\")\n    \n    if (missing(theta))\n      stop(\"Need to specify theta tuning parameter.\")\n    if (!is.numeric(theta)  )\n      stop(\"No numeric theta specified.\")\n    \n    if (missing(LoanAge))\n      stop(\"Need to specify theta tuning parameter.\")\n    if (!is.numeric(LoanAge)  )\n      stop(\"No numeric theta specified.\")\n    \n    alpha - beta * exp(-theta * LoanAge)}\n  \n  #----------------------------------\n  # Seasonality is modeled as a sin wave\n  # a is the amplitude of the wave an set the maximum seasonal factor\n  # Month is the calendar month (1..., 12) numeric\n  # b is a location parameter shifts the peak values > 1 shift left values < 1 shift right\n  Seasonality <- function( alpha = numeric(), Month = numeric(), theta= numeric()){\n    \n    if (missing(alpha))\n      stop(\"Need to specify alpha tuning parameter.\")\n    if (!is.numeric(alpha)  )\n      stop(\"No numeric alpha specified.\")\n    \n    if (missing(Month))\n      stop(\"Need to specify Month variable.\")\n    if (!is.numeric(Month)  )\n      stop(\"No numeric alpha specified.\")\n    \n    if (missing(theta))\n      stop(\"Need to specify Month variable.\")\n    if (!is.numeric(theta)  )\n      stop(\"No numeric alpha specified.\")\n    \n    (1  + alpha *sin((pi/2 * (Month + theta - 3)) / 3 - 1))}\n  \n  #-------------------------------------\n  # arctanget function with a location parameter\n  Borrower.Incentive <- function(incentive = numeric(), theta1 = numeric(), theta2 = numeric(), beta = numeric(), location = numeric()) { \n    theta1 + theta2 * atan(incentive + pi * (beta * ((location - atan(incentive))/pi))) \n  }\n  \n  #-----------------------------------\n  # Burnout is an exponentially decreasing function\n  # a is the coefficient on the burnout varaible and b is the measure of burnout\n  Burnout <- function(beta1 = numeric(), beta2= numeric(), MaxIncen = numeric(), LoanAge = numeric()){\n    exp(beta1 * LoanAge +  beta2 * MaxIncen)\n  }  \n\n  # The Bond Lab base prepayment model\n  #----------------------------------------------------------------------------------------------------\n  Prepayment.Model <- function(ModelTune = \"character\", LoanAge = vector(), \n                               Month = vector(), incentive = vector(), Burnout.maxincen = numeric()){\n      \n      TurnoverRate        = ModelTune@TurnoverRate                       \n      Seasoning.alpha     = ModelTune@Turnover.alpha\n      Seasoning.beta      = ModelTune@Turnover.beta \n      Seasoning.theta     = ModelTune@Turnover.theta\n      Seasonality.alpha   = ModelTune@Seasonality.alpha\n      Seasonality.theta   = ModelTune@Seasonality.theta\n      Fast.theta1         = ModelTune@Incentive.Fast.theta.1  \n      Fast.theta2         = ModelTune@Incentive.Fast.theta.2 \n      Fast.beta           = ModelTune@Incentive.Fast.beta \n      Fast.location       = ModelTune@Incentive.Fast.eta\n      Slow.theta1         = ModelTune@Incentive.Slow.theta.1 \n      Slow.theta2         = ModelTune@Incentive.Slow.theta.2 \n      Slow.beta           = ModelTune@Incentive.Slow.beta \n      Slow.location       = ModelTune@Incentive.Slow.eta\n      Burnout.beta1       = ModelTune@Burnout.beta.1 \n      Burnout.beta2       = ModelTune@Burnout.beta.2\n    \n    # All of the above needs to made into a model tuning class \n    # Restate the turnover rate as a single monthly mortality rate\n    \n    Turnover.Rate <- 1-(1 - TurnoverRate)^(1/12)\n    \n    Turnover <- Turnover.Rate * \n      Seasoning(alpha = Seasoning.alpha, beta = Seasoning.beta, theta = Seasoning.theta, LoanAge = LoanAge) *\n      Seasonality(alpha = Seasonality.alpha, Seasonality.theta, Month = Month)\n    \n    # Calculate the Borrower Refinance Response\n    Fast <- Borrower.Incentive(incentive = incentive, theta1 = Fast.theta1, theta2 = Fast.theta2, beta = Fast.beta, location = Fast.location)\n    Slow <- Borrower.Incentive(incentive = incentive, theta1 = Slow.theta1, theta2 = Slow.theta2, beta = Slow.beta, location = Slow.location)\n    Burnout <- Burnout(beta1 = Burnout.beta1, beta2 = Burnout.beta2, MaxIncen = Burnout.maxincen, LoanAge = LoanAge)\n    \n    Refinance <- (Fast * Burnout) + (Slow * (1-Burnout))\n    \n    SMM = Refinance + Turnover\n    \n    SMM <-pmax(0, SMM)\n    \n  }\n  \n   \n  # ---------  This function is the prepayment model and serves as a constructor for the prepayment model vector \n  # ---------  Prepayment Assumption\n  PrepaymentAssumption <- function(bond.id = \"character\", TermStructure = \"character\", ModelTune = \"character\", Burnout = numeric(),\n                                   PrepaymentAssumption = \"character\", ...,begin.cpr = numeric(), end.cpr = numeric(), \n                                   seasoning.period = numeric(), CPR = numeric()){\n    #Check for a valid prepayment assumption\n    if(!PrepaymentAssumption %in% c(\"MODEL\", \"CPR\", \"PPC\")) stop(\"Not a Valid Prepayment Assumption\")\n    PrepayAssumption <- PrepaymentAssumption    \n    \n    #Error Trap the CPR assumption\n    if(PrepaymentAssumption == \"CPR\") if(CPR >=1) {CPR = CPR/100} else {CPR = CPR}\n    #PPC function has error trapping feature so there is no need to error trap for PPC\n    \n    NoteRate = bond.id@GWac\n    FirstPmtDate = as.Date(bond.id@FirstPrinPaymentDate, \"%m-%d-%Y\")\n    LastPmtDate = as.Date(bond.id@LastPmtDate, \"%m-%d-%Y\")\n    FinalPmtDate = as.Date(bond.id@FinalPmtDate, \"%m-%d-%Y\")\n    NextPmtDate = as.Date(bond.id@NextPmtDate, \"%m-%d-%Y\")\n    \n    col.names <- c(\"Period\", \"PmtDate\", \"LoanAge\", \"TwoYearFwd\", \"TenYearFwd\", \"MtgRateFwd\", \"SMM\")\n    \n    Mtg.Term = as.integer(difftime(FinalPmtDate, FirstPmtDate, units = \"days\")/30.44) +1\n    Remain.Term = as.integer(difftime(FinalPmtDate, LastPmtDate, units = \"days\")/30.44)\n    Period = seq(from = 1, to = Remain.Term, by = 1)\n    PmtDate = as.Date(NextPmtDate)  %m+% months(seq(from = 0, to = Remain.Term-1, by = 1)) \n    LoanAge = as.integer(difftime(as.Date(NextPmtDate)  %m+% months(seq(from = 1, to = Remain.Term, by = 1)), \n                                  FirstPmtDate, units = \"days\")/30.44) + 1\n    \n    NoteRate =  as.numeric(rep(NoteRate, length(LoanAge)))\n    Mtg.Rate =  as.numeric(TermStructure@TenYearFwd[1:length(LoanAge)] + .80)\n    Incentive =  as.numeric(NoteRate - Mtg.Rate)\n    Burnout = bond.id@Burnout\n    \n      \n    if(PrepaymentAssumption == \"MODEL\")\n      {SMM = Prepayment.Model(ModelTune = ModelTune, LoanAge = LoanAge, Month = as.numeric(format(PmtDate, \"%m\")), \n                              incentive = Incentive, Burnout.maxincen = Burnout)} \n      else \n      {if(PrepaymentAssumption == \"PPC\") \n      {SMM = as.numeric(1-(1-PPC.Ramp(begin.cpr = begin.cpr, end.cpr = end.cpr, \n                                      season.period = seasoning.period, period = LoanAge))^(1/12))} \n      else\n      {SMM = rep(1-(1-CPR)^(1/12), Remain.Term)}\n      }\n    \n    new(\"PrepaymentAssumption\",\n        PrepayAssumption = as.character(PrepayAssumption),\n        PPCStart = if(PrepaymentAssumption == \"PPC\") {begin.cpr} else {0},\n        PPCEnd = if(PrepaymentAssumption == \"PPC\") {end.cpr} else {0},\n        PPCSeasoning = if(PrepaymentAssumption == \"PPC\") {seasoning.period} else {0},\n        NoteRate = as.numeric(NoteRate),\n        FirstPmtDate = as.character(FirstPmtDate),\n        LastPmtDate = as.character(LastPmtDate),\n        FinalPmtDate = as.character(FinalPmtDate),\n        Period = Period,\n        PmtDate = as.character(PmtDate),\n        LoanAge = as.numeric(LoanAge),\n        MtgRateFwd = Mtg.Rate,\n        Incentive = Incentive,\n        SMM = as.numeric(SMM)\n    )\n        \n  }\n  \n# ---------------- This function is the dollar roll analysis ---------------------------\n# ---------------- Currently the function calcualtes the 1 month roll ------------------\n# ---------------- Upgrade the bond basis function for actual/actual day count ---------  \n  DollarRoll <- function(bond.id = \"character\", price = numeric(), drop = numeric(), original.bal = numeric(), \n                         settlement.date = \"character\", fwd.settlement.date = \"character\", \n                         reinvestment.rate = numeric(), finance.rate = numeric(),\n                         MortgageCashFlow = \"character\") {\n    \n    #need to error trap these inputs\n    #reinvestment rate, drop\n    \n    #Error Trap the user's price input\n    if(price <= 1) {price = price} else {price = price/100}\n    if(price <= 0) stop(\"No valid bond price\")\n    \n    #Error Trap the user's drop input\n    #if(drop < 1/32) {drop = drop} else {drop = drop/100}\n    \n    #Here upgrade the bond basis function to include actual day count\n    settlement.date = as.Date(settlement.date, \"%m-%d-%Y\")\n    fwd.settlement.date = as.Date(fwd.settlement.date, \"%m-%d-%Y\")\n    reinvestment.days = as.numeric(difftime(fwd.settlement.date, settlement.date, units = \"days\"))\n    \n    Factor = bond.id@MBSFactor\n    CurrentBal = as.numeric(original.bal * Factor)\n    BeginningMarketValue = original.bal * Factor * price\n    \n    IssueDate = as.Date(bond.id@IssueDate)\n    DatedDate = as.Date(bond.id@DatedDate)\n    Maturity = as.Date(bond.id@Maturity)\n    Frequency = as.numeric(bond.id@Frequency)\n    Coupon = as.numeric(bond.id@Coupon)\n    \n    FinalPmtDate = as.Date(bond.id@FinalPmtDate, \"%m-%d-%Y\")\n    LastPmtDate = as.Date(bond.id@LastPmtDate, \"%m-%d-%Y\")\n    NextPmtDate = as.Date(bond.id@NextPmtDate, \"%m-%d-%Y\")\n    RemainingTerm = as.integer(difftime(FinalPmtDate, LastPmtDate, units = \"days\")/30.44)\n    FwdPrice = price - (drop/100)\n    reinvestment.rate = reinvestment.rate \n    \n    #Dollar Roll Hold versus Roll Analysis..\n    #Dollar Roll Proceeds\n    Accrued = MortgageCashFlow@Accrued\n    TotalProceeds = BeginningMarketValue + Accrued\n    ReinvestmentIncome = as.numeric(TotalProceeds * reinvestment.rate * (reinvestment.days/360))\n    TotalRollProceeds = TotalProceeds + ReinvestmentIncome\n    \n    #Hold Proceeds - Calculate the value of holding the MBS\n    ScheduledPrin = as.numeric(MortgageCashFlow@ScheduledPrin[1])\n    PrepaidPrin = as.numeric(MortgageCashFlow@PrepaidPrin[1])\n    PassThroughInterest = as.numeric(MortgageCashFlow@PassThroughInterest[1])\n    RemainingBalance = as.numeric(MortgageCashFlow@EndingBal[1])\n    \n    #Forward settlement and payment dates to compute the value of holding versus rolling\n    #Roll Settlement Dates forward by the roll months.  For example one month roll, two months\n    #Default value is one month\n    \n    FwdNextPmtDate = NextPmtDate %m+% months(1) #The months (1) should be a variable allowing for two-, and three- months\n    FwdLastPmtDate = LastPmtDate %m+% months(1)\n    days.to.nextpmt = BondBasisConversion(issue.date = IssueDate, start.date = DatedDate, end.date = Maturity,\n                                          settlement.date = fwd.settlement.date, lastpmt.date = FwdLastPmtDate, nextpmt.date = FwdNextPmtDate)\n    days.to.nextpmt = days.to.nextpmt * 360\n    days.between.pmtdate = ((12/Frequency)/12) * 360\n    days.of.accrued = (days.between.pmtdate - days.to.nextpmt) \n    \n    FutureValueofPmts = ScheduledPrin + PrepaidPrin + PassThroughInterest\n    FuturePrincipalProceeds = RemainingBalance * FwdPrice \n    FwdAccrued = (days.of.accrued/days.between.pmtdate) * as.numeric(MortgageCashFlow@MonthlyInterest[2])\n    FutureValueHold = FutureValueofPmts + FuturePrincipalProceeds + FwdAccrued\n    \n    #Compute the Roll Economics....\n    #Hold or Roll Analysis and Economics of Trade  \n    if (TotalRollProceeds > FutureValueHold) \n    HoldorRoll = as.character(\"Roll\") else HoldorRoll = as.character(\"Hold\")  \n    Advantage = as.numeric(abs(TotalRollProceeds - FutureValueHold))\n    \n    #Compute the days between the roll settlment date and the payment date\n    #This is to derive the discounted value of the carry between the settlement date and the payment date\n    #The discount rate is applied to the Future Value of the payments and is the Discounted Value of the Carry\n    MBSPmtDate = as.Date(MortgageCashFlow@PmtDate[1], \"%Y-%m-%d\")\n    settlement.day.diff = as.integer(difftime(MBSPmtDate, fwd.settlement.date, units = \"days\"))\n    DiscValueofCarry = FutureValueofPmts * ((1 +finance.rate) ^ (settlement.day.diff/360))\n    \n    FutureValuePrinCarry = (RemainingBalance * price) + FwdAccrued + DiscValueofCarry\n    FinanceCost = as.numeric(TotalProceeds * finance.rate * (reinvestment.days/361))\n    TotalFutureValue = FutureValuePrinCarry - FinanceCost\n    \n    DropImpliedValue = ((TotalFutureValue - TotalProceeds)/RemainingBalance) * 32\n    \n    new(\"DollarRoll\",\n        #MBS price and settlment information\n        SettlementDate = as.character(settlement.date),\n        FwdSettlementDate = as.character(fwd.settlement.date),\n        Price = price * 100,\n        Drop = drop,\n        FwdPrice = FwdPrice * 100,\n        # MBS information\n        GrossCoupon = bond.id@GWac,\n        NetCoupon = bond.id@Coupon,\n        OriginalTerm = bond.id@AmortizationTerm,\n        RemainingTerm = RemainingTerm,\n        OrigBalance = original.bal,\n        CurrentBalance = CurrentBal,\n        #Settlement information\n        PrincipalProceeds = BeginningMarketValue,\n        Accrued = Accrued,\n        TotalProceeds = TotalProceeds,\n        DaysInterest = reinvestment.days,\n        ReinvestmentIncome = ReinvestmentIncome,\n        # MBS hold information\n        ScheduledPrin = ScheduledPrin,\n        PrepaidPrin = PrepaidPrin,\n        PassThroughInterest = PassThroughInterest,\n        FutureValueHold = FutureValueHold,\n        RemainingBalance = RemainingBalance,\n        FuturePrincipalProceeds = FuturePrincipalProceeds,\n        FwdAccrued = FwdAccrued,\n        # Investor financing rates\n        FinanceRate = finance.rate,\n        ReinvestmentRate = reinvestment.rate,\n        FutureValueRoll = TotalRollProceeds,\n        FutureValuePrinCarry = FutureValuePrinCarry,\n        DiscValueofCarry = DiscValueofCarry,\n        # Roll analysis\n        HoldorRoll = HoldorRoll,\n        Advantage = Advantage,\n        TotalFutureValue = TotalFutureValue,\n        DropImpliedValue = DropImpliedValue,\n        MortgageCashFlow\n    )\n  }\n\n#------- Scenario Function --------\n# opens connection to scenario library\n#----------------------------------\n  Mtg.Scenario <- function(bond.id =\"character\", settlement.date = \"character\", price = numeric(), original.bal = numeric(),  \n                       scenario.set = vector(), rates.data = \"character\", method = \"character\", \n                       PrepaymentAssumption = \"character\",..., ModelTune = \"character\", Burnout = numeric(),\n                       begin.cpr = numeric(), end.cpr = numeric(), seasoning.period = numeric(), CPR = numeric()) { \n    \n    if(missing(method)) method = \"ns\"\n    \n    ScenarioResult <- list()\n    \n    for(i in 1:length(scenario.set)){\n      conn <- gzfile(description = paste(\"~/BondLab/Scenario/\", as.character(scenario.set[i]), \".rds\", sep =\"\"), open = \"rb\")        \n      \n      Scenario <- readRDS(conn) \n      \n      rates = rates.data\n      rates[1,2:length(rates)] = Scenario@Formula(rates[1,1:length(rates)], Shiftbps = Scenario@Shiftbps)\n      \n      TermStructure = TermStructure(rates.data = rates, method = method)\n      \n      Prepayment = PrepaymentAssumption(bond.id = bond.id, \n                                        TermStructure = TermStructure, \n                                        PrepaymentAssumption = PrepaymentAssumption, ModelTune = ModelTune, Burnout = Burnout, \n                                        begin.cpr = begin.cpr, end.cpr = end.cpr, seasoning.period = seasoning.period, CPR = CPR)\n\n      MortgageCashFlow = MortgageCashFlows(bond.id = bond.id, original.bal = original.bal, settlement.date = settlement.date, \n                                           price = price, PrepaymentAssumption = Prepayment)\n      \n      InterpolateCurve <- loess(as.numeric(rates.data[1,2:9])~as.numeric(rates.data[2,2:9]), \n                                               data = data.frame(rates.data))\n      \n      SpreadtoCurve <- (MortgageCashFlow@YieldToMaturity * 100) - predict(InterpolateCurve, MortgageCashFlow@WAL )\n      \n      Scenario <- new(\"Mtg.Scenario\",  \n                      Period = MortgageCashFlow@Period,\n                      PmtDate = MortgageCashFlow@PmtDate,\n                      TimePeriod = MortgageCashFlow@TimePeriod,\n                      BeginningBal = MortgageCashFlow@BeginningBal,\n                      PassThroughInterest = MortgageCashFlow@PassThroughInterest,\n                      ScheduledPrin = MortgageCashFlow@ScheduledPrin,\n                      PrepaidPrin = MortgageCashFlow@PrepaidPrin,\n                      EndingBal = MortgageCashFlow@EndingBal,\n                      TotalCashFlow = MortgageCashFlow@PassThroughInterest + \n                      MortgageCashFlow@ScheduledPrin + \n                      MortgageCashFlow@PrepaidPrin,\n                      spotrate = TermStructure@spotrate,\n                      forwardrate = TermStructure@forwardrate,\n                      SMM = Prepayment@SMM,\n                      YieldToMaturity = MortgageCashFlow@YieldToMaturity,\n                      WAL = MortgageCashFlow@WAL,\n                      SpreadToInterCurve = SpreadtoCurve,\n                      ModDuration = MortgageCashFlow@ModDuration,\n                      Convexity = MortgageCashFlow@Convexity,\n                      Scenario\n      )\n\n      ScenarioResult <- append(ScenarioResult, Scenario)\n\n    } # end loop\n    \n    close(conn)\n  \n    new(\"Mtg.ScenarioSet\", \n        Scenario = ScenarioResult,\n        MortgageCashFlow)\n    \n    \n  } # scenario end function\n  \n  \n# -------------------------------\n# Rate of Return Analysis\n# -------------------------------\n  RateofReturn <- function(ReinvestmentRate = numeric(), ReceivedCF = \"character\", \n                           RemainingCF = \"character\", SpotCurve = \"character\", FwdCurve = \"character\", HorizonSpread = numeric()) {\n    \n  }\n# --------------------------------\n# Bond Analytics Functions - THESE ARE THE BOND LAB ENGINES !!!\n# These functions are different from the above they use the functions together\n# to analyze a bond or mortgage backed security using the above functions and construct the appropriate objects (classes)  \n# --------------------------------\n\n# This function analyzes a standard non callable bond and serves as the constructor function\n# These are the engines  \n# -----------------------------------\n  BondAnalytics <- function (bond.id = \"character\", principal = numeric(), price = numeric(), trade.date = \"character\", \n                           settlement.date = \"character\", method = method) \n{\n\n  #Error Trap Settlement Date and Trade Date order.  This is not done in the Error Trap Function because that function is \n  #to trap errors in bond information that is passed into the functions.  It is trapped here because this is the first use of trade date\n  if(trade.date > settlement.date) stop (\"Trade Date Must be less than settlement date\")\n  \n  #Default method for TermStructure\n  if(missing(method)) method = \"ns\"\n  \n  #Rate Delta is set to 1 (100 basis points) for effective convexity calculation                          \n  Rate.Delta = 1\n  \n  # The first steo is to read in the Bond Detail\n  bond.id <- readRDS(paste(\"~/BondLab/BondData/\",bond.id, \".rds\", sep = \"\"))\n  #Call the desired curve from rates data folder\n  trade.date = as.Date(trade.date, \"%m-%d-%Y\")\n  rates.data <- readRDS(paste(\"~/BondLab/RatesData/\", trade.date, \".rds\", sep = \"\"))\n  \n  #The first step is to call the desired coupon curve into memory \n  #This is done with the TermStructure function which creates the class TermStructure\n  TermStructure <- TermStructure(rates.data = rates.data, method = method)\n\n  #The second step is to call the bond cusip details and calculate Bond Yield to Maturity, Duration, Convexity and CashFlow. \n  #The BondCashFlows function this creates the class BondCashFlows are held in class BondCashFlows\n  BondCashFlow <- BondCashFlows(bond.id = bond.id, principal = principal, settlement.date = settlement.date, price = price)\n  \n  #The third step is to calculate effective duration, convexity, and key rate durations and key rate convexities\n  #This is done with the BondTermStructureFunction this creates the class BondTermStructure\n  BondTermStructure <- BondTermStructure(bond.id = BondCashFlow, Rate.Delta = Rate.Delta, TermStructure = TermStructure, \n                                         principal = principal, price = price, cashflow = BondCashFlow)\n  \n  new(\"BondAnalytics\", bond.id, BondCashFlow, BondTermStructure, TermStructure)\n  \n  }\n\n\n  # This function analyzes a standard pass through security and serves as the constructor function\n  #--------------------------------------  \n  PassThroughAnalytics <- function (bond.id = \"character\", original.bal = numeric(), price = numeric(), trade.date = \"character\", \n                                  settlement.date = \"character\", method = \"character\", scenario.set = vector(),\n                                  PrepaymentAssumption = \"character\", ..., begin.cpr = numeric(), end.cpr = numeric(), seasoning.period = numeric(), CPR = numeric()\n                                 ) \n  {\n  \n  #Error Trap Settlement Date and Trade Date order.  This is not done in the Error Trap Function because that function is \n  #to trap errors in bond information that is passed into the functions.  It is trapped here because this is the first use of trade date\n  if(trade.date > settlement.date) stop (\"Trade Date Must be less than settlement date\")\n  \n  #Default method for TermStructure\n  if(missing(method)) method = \"ns\"\n  \n  #Rate Delta is set to 1 (100 basis points) for effective convexity calculation                          \n  Rate.Delta = 1\n  \n  # The first step is to read in the Bond Detail, rates, and Prepayment Model Tuning Parameters\n  conn1 <-  gzfile(paste(\"~/BondLab/BondData/\",bond.id, \".rds\", sep = \"\"), open = \"rb\")\n  bond.id = readRDS(conn1)\n\n  \n  #Call the desired curve from rates data folder\n  conn2 <- gzfile(description = paste(\"~/BondLab/RatesData/\", as.Date(trade.date, \"%m-%d-%Y\"), \".rds\", sep = \"\"), open = \"rb\")\n  rates.data <- readRDS(conn2)\n\n  #Call Prepayment Model Tuning Parameters\n  conn3 <- gzfile(description = paste(\"~/BondLab/PrepaymentModel/\", as.character(bond.id@Model), \".rds\", sep =\"\"), open = \"rb\")        \n  ModelTune <- readRDS(conn3)\n  \n  Burnout = bond.id@Burnout\n \n  #The second step is to call the desired coupon curve into memory \n  #This is done with the TermStructure function which creates the class TermStructure\n  TermStructure <- TermStructure(rates.data = rates.data, method = method)\n  \n  #Third if mortgage security call the prepayment model\n  PrepaymentAssumption <- PrepaymentAssumption(bond.id = bond.id, TermStructure = TermStructure, \n  PrepaymentAssumption = PrepaymentAssumption, ModelTune = ModelTune, Burnout = Burnout, \n  begin.cpr = begin.cpr, end.cpr = end.cpr, seasoning.period = seasoning.period, CPR = CPR)\n    \n  #The fourth step is to call the bond cusip details and calculate Bond Yield to Maturity, Duration, Convexity and CashFlow. \n  #The BondCashFlows function this creates the class BondCashFlows are held in class BondCashFlows\n  MortgageCashFlow <- MortgageCashFlows(bond.id = bond.id, original.bal = original.bal, settlement.date = settlement.date, \n                      price = price, PrepaymentAssumption = PrepaymentAssumption)\n  \n  #The fifth step is to calculate effective duration, convexity, and key rate durations and key rate convexities\n  #This is done with the BondTermStructureFunction this creates the class BondTermStructure\n  MortgageTermStructure <- BondTermStructure(bond.id = MortgageCashFlow, Rate.Delta = Rate.Delta, TermStructure = TermStructure, \n                          principal = original.bal *  MortgageCashFlow@MBSFactor, price = price, cashflow = MortgageCashFlow)\n  \n  Scenario <- Mtg.ScenarioAnalysis(scenario.set = scenario.set, bond.id = bond.id@ID, original.bal = original.bal, \n                                   trade.date = trade.date, settlement.date = settlement.date, price = price, \n                                   PrepaymentAssumption = \"MODEL\")\n\n  closeAllConnections()\n  \n  new(\"PassThroughAnalytics\", bond.id, MortgageCashFlow, MortgageTermStructure, TermStructure, PrepaymentAssumption, Scenario)    \n  }\n   \n  #----------------------------------\n  #Agency Mortgage Dollar Roll\n    \n    DollarRollAnalytics <- function(bond.id = \"character\", original.bal= numeric(), price = numeric(), drop = numeric(), trade.date = \"character\", \n                           settlement.date = \"character\", fwd.settlement.date = \"character\", reinvestment.rate = numeric(),  \n                           finance.rate = numeric(), method = \"ns\", PrepaymentAssumption = \"character\", ...,begin.cpr = numeric(), end.cpr = numeric(), seasoning.period = numeric(), CPR = numeric()) {\n    \n    #Error Trap Settlement Date and Trade Date order.  This is not done in the Error Trap Function because that function is \n    #to trap errors in bond information that is passed into the functions.  It is trapped here because this is the first use of trade date\n    if(trade.date > settlement.date) stop (\"Trade Date Must be less than settlement date\")\n    \n    #Default method for TermStructure\n    if(missing(method)) method = \"ns\"\n    \n    #Rate Delta is set to 1 (100 basis points) for effective convexity calculation                          \n    Rate.Delta = 1\n    \n    # The first step is to read in the Bond Detail, rates, and Prepayment Model Tuning Parameters\n    bond.id <- readRDS(paste(\"~/BondLab/BondData/\",bond.id, \".rds\", sep = \"\"))\n    #Call the desired curve from rates data folder\n    trade.date = as.Date(trade.date, \"%m-%d-%Y\")\n    rates.data <- readRDS(paste(\"~/BondLab/RatesData/\", trade.date, \".rds\", sep = \"\"))\n    #Call Prepayment Model\n    ModelTune <- readRDS(paste(\"~/BondLab/PrepaymentModel/\",bond.id@Model,\".rds\", sep = \"\"))\n    Burnout = bond.id@Burnout\n   \n    #The second step is to call the desired coupon curve into memory \n    #This is done with the TermStructure function which creates the class TermStructure\n    TermStructure <- TermStructure(rates.data = rates.data, method = method)\n    \n    # Third if mortgage security call the prepayment model\n    PrepaymentAssumption <- PrepaymentAssumption(bond.id = bond.id, TermStructure = TermStructure, \n                                  PrepaymentAssumption = PrepaymentAssumption, ModelTune = ModelTune, Burnout = Burnout, \n                                  begin.cpr = begin.cpr, end.cpr = end.cpr, seasoning.period = seasoning.period, CPR = CPR)\n    \n    #The fourth step is to call the bond cusip details and calculate Bond Yield to Maturity, Duration, Convexity and CashFlow. \n    #The BondCashFlows function this creates the class BondCashFlows are held in class BondCashFlows\n    MortgageCashFlow <- MortgageCashFlows(bond.id = bond.id, original.bal = original.bal, settlement.date = settlement.date, \n                                          price = price, PrepaymentAssumption = PrepaymentAssumption)\n    \n  \n    DollarRoll <- DollarRoll(bond.id = bond.id, price = price, drop = drop, original.bal = original.bal, \n                             settlement.date = settlement.date, fwd.settlement.date = fwd.settlement.date, \n                             reinvestment.rate = reinvestment.rate, finance.rate = finance.rate, MortgageCashFlow = MortgageCashFlow)\n   return(DollarRoll)\n  }\n  \n  #-------------- Scenario Analysis\n  \n  Mtg.ScenarioAnalysis <- \n    function( scenario.set = vector(), bond.id = \"character\", original.bal= numeric(), \n              price = numeric(), trade.date = \"character\", settlement.date = \"character\", method = \"character\", \n              PrepaymentAssumption = \"character\", ..., \n              begin.cpr = numeric(), end.cpr = numeric(), seasoning.period = numeric(), CPR = numeric()) {\n      \n      #Error Trap Settlement Date and Trade Date order.  This is not done in the Error Trap Function because that function is \n      #to trap errors in bond information that is passed into the functions.  It is trapped here because this is the first use of trade date\n      if(trade.date > settlement.date) stop (\"Trade Date Must be less than settlement date\")\n      \n      #Call the desired curve from rates data folder\n      #trade.date = as.Date(trade.date, \"%m-%d-%Y\")\n      \n      #Default method for TermStructure\n      if(missing(method)) method = \"ns\"\n      \n      #Rate Delta is set to 1 (100 basis points) for effective convexity calculation                          \n      Rate.Delta = 1\n      \n      #Initialize the Scenario Result \n       \n      # The first step is to read in the Bond Detail, rates, and Prepayment Model Tuning Parameters\n      bond.id <- readRDS(paste(\"~/BondLab/BondData/\",bond.id, \".rds\", sep = \"\"))\n      #Call the desired curve from rates data folder\n      trade.date = as.Date(trade.date, \"%m-%d-%Y\")\n      rates.data <- readRDS(paste(\"~/BondLab/RatesData/\", as.Date(trade.date, \"%m-%d-%Y\"), \".rds\", sep = \"\"))\n      #Call Prepayment Model\n      ModelTune <- readRDS(paste(\"~/BondLab/PrepaymentModel/\",bond.id@Model,\".rds\", sep = \"\"))\n      Burnout = bond.id@Burnout\n            \n      Scenario <- Mtg.Scenario(bond.id = bond.id, settlement.date = settlement.date, price = price, original.bal = original.bal,\n                           scenario.set = scenario.set, rates.data = rates.data,\n                           PrepaymentAssumption = PrepaymentAssumption, ModelTune = ModelTune, Burnout = Burnout,\n                           begin.cpr = begin.cpr, end.cpr = end.cpr, seasoning.period = seasoning.period, CPR = CPR)\n      \n    } # end of analysis\n  \n    #----------------------------------\n  # Helper Functions These function help to manage\n  # The data sources   \n  #----------------------------------\n\n  # Swap Curve data creates a data base of daily yield\n  # curves using swap rate data from the Federal Reserve\n\n  SwapRateData <- function(datafile = \"character\", maturityvector = numeric()){\n  #========== Read Swap Rate Data ===========================\n  SwapRateData <-read.csv(datafile, header = TRUE, as.is = TRUE)\n  #======== remove month and year data and reorder dataset\n  RowCount = nrow(SwapRateData)\n  ColCount = ncol(SwapRateData)\n  \n  for(i in 1:RowCount) {\n    if(SwapRateData[i,ColCount] != \"ND\") {data = SwapRateData[i,]                                      \n                                          data <- rbind(data, as.numeric(maturityvector))\n                                          saveRDS(data, paste(data[1,1], \".rds\", sep = \"\"), compress = TRUE)}}\n  }\n\n  # Multiple plot function\n  # Source: cookbook for R\n  # Author: Winston Change\n  # ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)\n  # - cols:   Number of columns in layout\n  # - layout: A matrix specifying the layout. If present, 'cols' is ignored.\n  #\n  # If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),\n  # then plot 1 will go in the upper left, 2 will go in the upper right, and\n  # 3 will go all the way across the bottom.\n\n  multiplot <- function(..., plotlist = NULL, file, cols = 1, layout = NULL) {\n  plots <- c(list(...), plotlist)\n  numPlots = length(plots)\n  \n  if (is.null(layout)) {\n    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),\n                     ncol = cols, nrow = ceiling(numPlots/cols))\n  }\n  \n  if (numPlots == 1) {\n    print(plots[[1]])\n    \n  } else {\n    grid.newpage()\n    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))\n    \n    for (i in 1:numPlots) {\n      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))\n      \n      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,\n                                      layout.pos.col = matchidx$col))\n      }\n    }\n  }\n\n\n  #-----------------------\n  # Classes these are the new classes used by by Bond Lab\n  #------------------------\n\n  # --- The following classes define standard bond analytics\n  setClass(\"BondDetails\",\n         representation(\n           Cusip = \"character\",\n           ID = \"character\",\n           BondType = \"character\",\n           Sector =\"character\",\n           Coupon = \"numeric\",\n           IssueDate = \"character\",\n           DatedDate = \"character\",\n           Maturity = \"character\",\n           LastPmtDate = \"character\",\n           NextPmtDate = \"character\",\n           Moody = \"character\",\n           SP = \"character\",\n           BondLab  = \"character\",\n           Frequency = \"numeric\",\n           BondBasis = \"character\",\n           Callable = \"character\",\n           Putable = \"character\",\n           SinkingFund = \"character\"))\n\n  setClass(\"BondCashFlows\",\n         representation(\n           Price = \"numeric\",\n           Accrued = \"numeric\",\n           YieldToMaturity = \"numeric\",\n           WAL = \"numeric\",\n           ModDuration = \"numeric\",\n           Convexity = \"numeric\",\n           Period = \"numeric\",\n           PmtDate = \"character\",\n           TimePeriod = \"numeric\",\n           PrincipalOutstanding = \"numeric\",  \n           CouponPmt = \"numeric\",\n           TotalCashFlow = \"numeric\"),\n         contains = \"BondDetails\")\n\n  setClass(\"BondTermStructure\",\n         representation(\n           SpotSpread = \"numeric\",   \n           EffDuration = \"numeric\",\n           EffConvexity = \"numeric\",\n           KeyRateTenor = \"numeric\",\n           KeyRateDuration = \"numeric\",\n           KeyRateConvexity = \"numeric\"),\n         contains = \"BondDetails\")\n\n# --- The folllowing classes define standard Mortgage Passthrough analytics\n  setClass(\"MBSDetails\", \n         representation(\n           Cusip = \"character\",\n           ID = \"character\",\n           BondType = \"character\",\n           Sector =\"character\",\n           Coupon = \"numeric\",\n           IssueDate = \"character\",\n           DatedDate = \"character\",\n           Maturity = \"character\",\n           LastPmtDate = \"character\",\n           NextPmtDate = \"character\",\n           PaymentDelay = \"numeric\",\n           Moody = \"character\",\n           SP = \"character\",\n           BondLab  = \"character\",\n           Frequency = \"numeric\",\n           BondBasis = \"character\",\n           GWac = \"numeric\",\n           AmortizationType = \"character\",\n           AmortizationTerm = \"numeric\",\n           Index = \"character\",\n           Margin = \"numeric\",\n           FirstPmtDate = \"character\",\n           FinalPmtDate = \"character\",\n           Servicing = \"numeric\",\n           PMI = \"numeric\",\n           Gfee = \"numeric\",\n           InitialInterest = \"character\",\n           InterestOnlyPeriod = \"numeric\",\n           FirstPrinPaymentDate = \"character\",\n           BalloonPmt = \"character\",\n           BalloonDate = \"character\",\n           MBSFactor = \"numeric\",\n           Model = \"character\",\n           Burnout = \"numeric\"\n         ))\n  \n  setClass(\"PrepaymentAssumption\",\n           representation(\n             PrepayAssumption = \"character\",\n             PPCStart = \"numeric\",\n             PPCEnd = \"numeric\",\n             PPCSeasoning = \"numeric\",\n             FirstPmtDate = \"character\",\n             LastPmtDate = \"character\",\n             FinalPmtDate = \"character\",\n             PmtDate = \"character\",\n             LoanAge = \"numeric\",\n             Period = \"numeric\",\n             NoteRate = \"numeric\",\n             MtgRateFwd = \"numeric\",\n             Incentive = \"numeric\",\n             SMM = \"numeric\"),\n             contains = \"MBSDetails\"\n           )\n\n  setClass(\"MortgageCashFlows\",\n         representation(\n           Price = \"numeric\",\n           Accrued = \"numeric\",\n           YieldToMaturity = \"numeric\",\n           WAL = \"numeric\",\n           ModDuration = \"numeric\",\n           Convexity = \"numeric\",\n           Period = \"numeric\",\n           PmtDate = \"character\",\n           TimePeriod = \"numeric\",\n           BeginningBal = \"numeric\",\n           MonthlyPmt = \"numeric\",\n           MonthlyInterest = \"numeric\",\n           PassThroughInterest = \"numeric\",\n           ScheduledPrin = \"numeric\",\n           #SMM = \"numeric\",\n           PrepaidPrin = \"numeric\",\n           EndingBal = \"numeric\",\n           ServicingIncome = \"numeric\",\n           PMIPremium = \"numeric\",\n           GFeePremium = \"numeric\",  \n           TotalCashFlow = \"numeric\"),\n           contains = \"MBSDetails\"\n         )\n\n  setClass(\"MortgageTermStructure\",\n         representation(\n           SpotSpread = \"numeric\",   \n           EffDuration = \"numeric\",\n           EffConvexity = \"numeric\",\n           KeyRateTenor = \"numeric\",\n           KeyRateDuration = \"numeric\",\n           KeyRateConvexity = \"numeric\"),\n         contains = \"MBSDetails\"\n         )\n\n  setClass(\"DollarRoll\",\n          representation(\n           SettlementDate = \"character\",\n           FwdSettlementDate = \"character\",  \n           GrossCoupon = \"numeric\",\n           NetCoupon = \"numeric\",\n           OriginalTerm = \"numeric\",\n           RemainingTerm = \"numeric\",\n           OrigBalance = \"numeric\",\n           CurrentBalance = \"numeric\",\n           Price = \"numeric\",\n           PrincipalProceeds = \"numeric\",\n           Accrued = \"numeric\",\n           TotalProceeds = \"numeric\",\n           DaysInterest = \"numeric\",\n           ReinvestmentIncome = \"numeric\",\n           ScheduledPrin = \"numeric\",\n           PrepaidPrin = \"numeric\",\n           PassThroughInterest = \"numeric\",\n           FutureValueHold = \"numeric\",\n           RemainingBalance = \"numeric\",\n           FuturePrincipalProceeds = \"numeric\",\n           FwdAccrued = \"numeric\",\n           Drop = \"numeric\",\n           FwdPrice = \"numeric\",\n           FinanceRate = \"numeric\",\n           ReinvestmentRate = \"numeric\",\n           HoldorRoll = \"character\",\n           Advantage = \"numeric\",\n           FutureValueRoll = \"numeric\",\n           DiscValueofCarry = \"numeric\",\n           FutureValuePrinCarry = \"numeric\",\n           TotalFutureValue = \"numeric\",\n           DropImpliedValue = \"numeric\"),\n           contains = \"MortgageCashFlows\"\n        ) \n\n# --- The following classes define rates and Prepayment model tune classes\n# --- these classes are used to pass term strucuture information and prepayment model\n# --- tuning paramaters  \n\n  setClass(\"TermStructure\",\n         representation(\n           tradedate = \"character\",\n           period = \"numeric\",\n           date = \"character\",\n           spotrate = \"numeric\",\n           forwardrate = \"numeric\",\n           TwoYearFwd = \"numeric\",\n           TenYearFwd = \"numeric\"\n           ))\n\n  setClass(\"PrepaymentModelTune\",\n        representation(\n          TurnoverRate = \"numeric\",\n          Turnover.alpha = \"numeric\",\n          Turnover.beta = \"numeric\",\n          Turnover.theta = \"numeric\",\n          Seasonality.alpha = \"numeric\",\n          Seasonality.theta = \"numeric\",\n          Incentive.Fast.theta.1 = \"numeric\",\n          Incentive.Fast.theta.2 = \"numeric\",\n          Incentive.Fast.beta = \"numeric\",\n          Incentive.Fast.eta = \"numeric\",\n          Incentive.Slow.theta.1 = \"numeric\",\n          Incentive.Slow.theta.2 = \"numeric\",\n          Incentive.Slow.beta = \"numeric\",\n          Incentive.Slow.eta = \"numeric\",\n          Burnout.beta.1 = \"numeric\",\n          Burnout.beta.2 = \"numeric\"\n          ))\n  \n# ----- The following classes define rate of return and valuation classes\n  setClass(\"Scenario\",\n          representation(\n          Name = \"character\",\n          Type = \"character\",\n          Horizon = \"character\",\n          ShiftType = \"character\",\n          Shiftbps = \"numeric\",\n          Formula = \"function\"\n          ))\n  \n  setClass(\"Mtg.Scenario\",\n           representation( \n           Period = \"numeric\",\n           PmtDate = \"character\",\n           TimePeriod = \"numeric\",\n           BeginningBal = \"numeric\",\n           PassThroughInterest = \"numeric\",\n           ScheduledPrin = \"numeric\",\n           PrepaidPrin = \"numeric\",\n           EndingBal = \"numeric\",\n           TotalCashFlow = \"numeric\",\n           spotrate = \"numeric\",\n           forwardrate = \"numeric\",\n           SMM = \"numeric\",\n           YieldToMaturity = \"numeric\",\n           WAL = \"numeric\",\n           SpreadToInterCurve = \"numeric\",\n           ModDuration = \"numeric\",\n           Convexity = \"numeric\"),\n             contains = \"Scenario\")\n\n  setClass(\"Mtg.ScenarioSet\",\n             representation(\n               Scenario = \"list\"),\n               contains = \"MortgageCashFlows\"\n           )\n        \n  setClass(\"RateofReturn\",\n         representation(\n         PmtDate = \"character\",\n         Period = \"numeric\",\n         ReinvestmentRate = \"numeric\",\n         ReceivedCF = \"numeric\",\n         ReInvestmentIncome = \"numeric\",\n         RemainingCF = \"numeric\",\n         HorizonSpread = \"numeric\"))\n\n#------ The classes BondCashFlows and BondTermStructure extends the BondAnalytics a single storage class for all bond analytics\n  setClass(\"BondAnalytics\", contains = c(\"MBSDetails\", \"BondCashFlows\", \"BondTermStructure\", \"TermStructure\"))\n\n#------ The classes MortgageCashFlows and Mortgage TermStructure extends the MortgageAnalytics a single storage class \n#------ for all mortgage passthrough analytics\n\n  setClass(\"PassThroughAnalytics\", \n           contains = c(\"MBSDetails\", \"MortgageCashFlows\", \"MortgageTermStructure\", \"TermStructure\", \"PrepaymentAssumption\", \"Mtg.ScenarioSet\"))\n\n\n#---------------------------------------\n# Bond Lab Initialize Set Generics\n#---------------------------------------\n  setGeneric(\n  name = \"BondCashFlows\",\n  def = function (bond.id = \"character\", principal = numeric(), settlement.date = \"character\", price = numeric())\n  {standardGeneric(\"BondCashFlows\")})\n\n  setGeneric(\n  name = \"MortgageCashFlows\",\n  def = function(bond.id = \"character\", original.bal = numeric(), settlement.date = \"character\", \n                 price = numeric(), PrepaymentAssumption = \"character\")\n  {standardGeneric(\"MortgageCashFlows\")})\n\n  setGeneric(\"BondTermStructure\",\n           def = function(bond.id = \"character\", Rate.Delta = numeric(), TermStructure = \"character\", principal = numeric(), \n                          price = numeric(), cashflow = \"character\")\n           {standardGeneric(\"BondTermStructure\")})\n\n  setGeneric(\"BondAnalytics\",\n           def = function (bond.id = \"character\", principal = numeric(), price = numeric(), trade.date = \"character\", \n                           settlement.date = \"character\", method = method)\n           {standardGeneric(\"BondAnalytics\")})\n\n  setGeneric(\"TermStructure\",\n           function(rates.data = \"character\", method = \"character\")\n           {standardGeneric(\"TermStructure\")})\n\n  setGeneric(\"PassThroughAnalytics\",\n           function (bond.id = \"character\", original.bal = numeric(), price = numeric(), trade.date = \"character\", \n                     settlement.date = \"character\", method = method, scenario.set = vector(), PrepaymentAssumption = \"character\",\n                     ..., begin.cpr = numeric(), end.cpr = numeric(), seasoning.period = numeric(), CPR = numeric())\n             {standardGeneric(\"PassThroughAnalytics\")})\n  \n  setGeneric(\"PrepaymentAssumption\",\n           function(bond.id = \"character\", TermStructure = \"character\", ModelTune = \"character\", Burnout = numeric(),\n                    PrepaymentAssumption = \"character\", ...,begin.cpr = numeric(), end.cpr = numeric(), \n                    seasoning.period = numeric(), CPR = numeric())\n           {standardGeneric(\"PrepaymentAssumption\")}\n           )  \n\n  setGeneric(\"RateofReturn\",\n           function(ReinvestmentRate = numeric(), ReceivedCF = \"character\", RemainingCF = \"character\",\n                    SpotCurve = \"character\", FwdCurve = \"character\", HorizonSpread = numeric())\n             {standardGenric(\"RateofReturn\")})\n\n  setGeneric(\"Seasoning\",\n           function (alpha = numeric(), beta = numeric (), theta = numeric(), LoanAge = numeric())\n             {standardGeneric(\"Seasoning\")})\n\n  setGeneric(\"Borrower.Incentive\",\n           function(incentive = numeric(), theta1 = numeric(), theta2 = numeric(), beta = numeric(), location = numeric())\n             {standardGeneric(\"Borrower.Incentive\")})\n\n  setGeneric(\"Burnout\",\n           function(beta1 = numeric(), beta2 = numeric(), MaxIncen = numeric(), LoanAge = numeric())\n             {standardGeneric(\"Burnout\")})\n\n  setGeneric(\"Seasonality\",\n           function(alpha = numeric(), Month = numeric(), theta = numeric())\n             {standardGeneric(\"Seasonality\")})\n  \n  setGeneric(\"Prepayment.Model\",\n           function(ModelTune = \"character\", LoanAge = numeric(), \n                    Month = numeric(), incentive = numeric(), Burnout.maxincen = numeric())\n             {standardGeneric(\"Prepayment.Model\")})  \n\n  setGeneric(\"DollarRoll\", function(bond.id = \"character\", price = numeric(), drop = numeric(), original.bal = numeric(), \n                         settlement.date = \"character\", fwd.settlement.date = \"character\", reinvestment.rate = numeric(), finance.rate = numeric(), MortgageCashFlow = \"character\")\n            {standardGeneric(\"DollarRoll\")})\n  \n  setGeneric(\"DollarRollAnalytics\", function(bond.id = \"character\", original.bal= numeric(), price = numeric(), drop = numeric(), trade.date = \"character\", \n                        settlement.date = \"character\", fwd.settlement.date = \"character\", reinvestment.rate = numeric(), finance.rate = numeric(), method = \"ns\", \n                        PrepaymentAssumption = \"character\", ...,begin.cpr = numeric(), end.cpr = numeric(), seasoning.period = numeric(), CPR = numeric())\n            {standardGeneric(\"DollarRollAnalytics\")})\n  \n  setGeneric(\"Mtg.Scenario\", function(bond.id =\"character\", settlement.date = \"character\", price = numeric(), original.bal = numeric(),\n                       scenario.set = vector(), rates.data = \"character\", method = \"character\", \n                       PrepaymentAssumption = \"character\",..., ModelTune = \"character\", Burnout = numeric(),\n                       begin.cpr = numeric(), end.cpr = numeric(), seasoning.period = numeric(), CPR = numeric())\n  {standardGeneric(\"Mtg.Scenario\")})\n  \n  setGeneric(\"Mtg.ScenarioAnalysis\", function(scenario.set = vector(), bond.id = \"character\", original.bal= numeric(), \n                         price = numeric(), trade.date = \"character\", settlement.date = \"character\", method = \"character\", \n                         PrepaymentAssumption = \"character\", ..., \n                         begin.cpr = numeric(), end.cpr = numeric(), seasoning.period = numeric(), CPR = numeric())\n              {standardGeneric(\"Mtg.ScenarioAnalysis\")})  \n  \n#-------------------------------\n#Bond Lab Set Methods \n#-------------------------------\nsetMethod(\"show\",\n          signature(object = \"BondCashFlows\"),\n          function (object) \n          {      \n            cat(\"Bond Description\", \"\\n\")\n            cat(\"BondId:\"); print(object@ID)\n            cat(\"Cusip:\"); print(object@Cusip)\n            cat(\"Coupon:\"); print(object@Coupon)\n            cat(\"Frequency:\"); print(object@Frequency)\n            cat(\"Basis:\"); print(object@BondBasis)\n            cat(\"Issue Date:\"); print(object@IssueDate)\n            cat(\"Last Payment Date:\"); print(object@LastPmtDate)\n            cat(\"Next Payment Date:\"); print(object@NextPmtDate)\n            cat(\"Maturity Date:\"); print(object@Maturity)\n            cat(\"Bond Valuation:\", \"\\n\")\n            cat(\"Price:\"); print(object@Price)\n            cat(\"Accrued:\"); print(object@Accrued)\n            cat(\"Yield to Maturity:\"); print(object@YieldToMaturity)\n            cat(\"Risk Metrics:\", \"\\n\")\n            cat(\"Weighted Average Life:\"); print(object@WAL)\n            cat(\"Modified Duration:\"); print(unname(object@ModDuration))\n            cat(\"Convexity:\"); print(unname(object@Convexity))\n            cat(\"Sector Detail:\", \"\\n\")\n            cat(\"Bond Type:\"); print(object@BondType)\n            cat(\"Sector:\"); print(object@Sector)\n            cat(\"Moodys:\"); print(object@Moody)\n            cat(\"S&P:\"); print(object@SP)\n            cat(\"BondLab Rating:\");print(object@BondLab)\n            \n            plotdata = as.data.frame(cbind(object@Period, object@TotalCashFlow))\n            colnames(plotdata) <- c(\"Period\", \"CashFlow\")\n            \n            plot <- ggplot(plotdata, aes(x= Period, y = CashFlow)) +\n              geom_bar(stat = \"identity\", fill = \"Grey\") +\n              theme_minimal() + \n              labs(fill = \"\") +\n              ylab(\"Bond Cash Flow\") +\n              xlab(\"Period\") +\n              theme(axis.title.y=element_text(angle = 90, size = 20)) +\n              theme(axis.text.y = element_text(angle = 90, size = 15)) +\n              theme(axis.title.x=element_text(angle = 0, size = 20)) +\n              theme(axis.text.x = element_text(angle = 0, size = 15)) +\n              theme(legend.position = c(.82,.73))\n                         \n            print(plot)\n\n          }\n)\n\nsetMethod(\"show\",\n          signature(object = \"MortgageCashFlows\"),\n          function (object) \n          {      \n            cat(\"Bond Description\", \"\\n\")\n            cat(\"BondId:\"); print(object@ID)\n            cat(\"Cusip:\"); print(object@Cusip)\n            cat(\"Coupon:\"); print(object@Coupon)\n            cat(\"Frequency:\"); print(object@Frequency)\n            cat(\"Basis:\"); print(object@BondBasis)\n            cat(\"Issue Date:\"); print(object@IssueDate)\n            cat(\"Last Payment Date:\"); print(object@LastPmtDate)\n            cat(\"Next Payment Date:\"); print(object@NextPmtDate)\n            cat(\"Maturity Date:\"); print(object@Maturity)\n            cat(\"Bond Valuation:\", \"\\n\")\n            cat(\"Price:\"); print(object@Price)\n            cat(\"Accrued:\"); print(object@Accrued)\n            cat(\"Yield to Maturity:\"); print(object@YieldToMaturity)\n            cat(\"Risk Metrics:\", \"\\n\")\n            cat(\"Weighted Average Life:\"); print(object@WAL)\n            cat(\"Modified Duration:\"); print(unname(object@ModDuration))\n            cat(\"Convexity:\"); print(unname(object@Convexity))\n            cat(\"Sector Detail:\", \"\\n\")\n            cat(\"Bond Type:\"); print(object@BondType)\n            cat(\"Sector:\"); print(object@Sector)\n            cat(\"Moodys:\"); print(object@Moody)\n            cat(\"S&P:\"); print(object@SP)\n            cat(\"BondLab Rating:\");print(object@BondLab)\n            \n            \n            plotdata = as.data.frame(cbind(object@Period, object@ScheduledPrin, object@PrepaidPrin, \n                          object@PassThroughInterest, object@ServicingIncome, object@PMIPremium, object@GFeePremium))\n            colnames(plotdata) <- c(\"Period\", \"Scheduled Prin\", \"Prepaid Prin\", \"PT Interest\", \"Servicing\", \"PMI\", \"GFee\")\n            plotdata = melt(plotdata, id = \"Period\")\n            \n            plot <- ggplot(plotdata, aes(x= Period, y = value, fill = variable)) +\n              geom_area() +\n              theme_minimal()+\n              scale_fill_brewer(palette = \"Greys\") +\n              labs(fill = \"\") +\n              ylab(\"Pool Cash Flow\") +\n              xlab(\"Period\") +\n              theme(axis.title.y=element_text(angle = 90, size = 20)) +\n              theme(axis.text.y = element_text(angle = 90, size = 15)) +\n              theme(axis.title.x=element_text(angle = 0, size = 20)) +\n              theme(axis.text.x = element_text(angle = 0, size = 15)) +\n              theme(legend.position = c(.82,.73))+\n              theme(legend.background = element_rect(fill = \"white\"))\n            \n            print(plot)\n          }\n)\n\nsetMethod(\"show\", \n          signature(object = \"BondAnalytics\"),\n          function(object)\n          {\n           cat(\"Bond Description\", \"\\n\")\n           cat(\"BondId:\"); print(object@ID)\n           cat(\"Cusip:\"); print(object@Cusip)\n           cat(\"Coupon:\"); print(object@Coupon)\n           cat(\"Frequency:\"); print(object@Frequency)\n           cat(\"Basis:\"); print(object@BondBasis)\n           cat(\"Issue Date:\"); print(object@IssueDate)\n           cat(\"Last Payment Date:\"); print(object@LastPmtDate)\n           cat(\"Next Payment Date:\"); print(object@NextPmtDate)\n           cat(\"Maturity Date:\"); print(object@Maturity)\n           cat(\"Bond Valuation:\", \"\\n\")\n           cat(\"Price:\"); print(object@Price)\n           cat(\"Accrued:\"); print(object@Accrued)\n           cat(\"Yield to Maturity:\"); print(object@YieldToMaturity)\n           cat(\"Risk Metrics:\", \"\\n\")\n           cat(\"Weighted Average Life:\"); print(object@WAL)\n           cat(\"Modified Duration:\"); print(unname(object@ModDuration))\n           cat(\"Convexity:\"); print(unname(object@Convexity))\n           cat(\"Effective Duration\"); print(unname(object@EffDuration))\n           cat(\"Effective Convexity\"); print(unname(object@EffConvexity))\n           cat(\"Sector Detail:\", \"\\n\")\n           cat(\"Bond Type:\"); print(object@BondType)\n           cat(\"Sector:\"); print(object@Sector)\n           cat(\"Moodys:\"); print(object@Moody)\n           cat(\"S&P:\"); print(object@SP)\n           cat(\"BondLab Rating:\");print(object@BondLab)\n           \n           plotdata1 = as.data.frame(cbind(object@Period, object@TotalCashFlow))\n           colnames(plotdata1) <- c(\"Period\", \"CashFlow\")\n           \n           plot1 <- ggplot(plotdata1, aes(x= Period, y = CashFlow)) +\n             geom_bar(stat = \"identity\", fill = \"Grey\") +\n             theme_minimal() + \n             labs(fill = \"\") +\n             ylab(\"Bond Cash Flow\") +\n             xlab(\"Period\") +\n             theme(axis.title.y=element_text(angle = 90, size = 20)) +\n             theme(axis.text.y = element_text(angle = 90, size = 15)) +\n             theme(axis.title.x=element_text(angle = 0, size = 20)) +\n             theme(axis.text.x = element_text(angle = 0, size = 15)) +\n             theme(legend.position = c(.82,.73))\n           \n           plotdata2 <- as.data.frame(cbind(object@KeyRateTenor, object@KeyRateDuration))\n           colnames(plotdata2) <- c(\"KRTenor\", \"KRDuration\")\n           \n           plot2 <- ggplot(plotdata2, aes(x = as.factor(KRTenor), y = KRDuration)) +\n             geom_bar(stat = \"identity\", fill = \"Grey\") +\n             theme_minimal() +\n             labs(fill = \"\") +\n             ylab(\"Key Rate Duration\") +\n             xlab(\"Key Rate Tenor\") +\n             theme(axis.title.y=element_text(angle = 90, size = 20)) +\n             theme(axis.text.y = element_text(angle = 90, size = 15)) +\n             theme(axis.title.x=element_text(angle = 0, size = 20)) +\n             theme(axis.text.x = element_text(angle = 0, size = 15)) +\n             theme(legend.position = c(.82,.73))\n           \n         multiplot(plot1, plot2, cols = 1)\n           \n          }\n          )\n\nsetMethod(\"show\", \n          signature(object = \"PassThroughAnalytics\"),\n          function(object)\n          {\n            cat(\"Bond Description\", \"\\n\")\n            cat(\"BondId:\"); print(object@ID)\n            cat(\"Cusip:\"); print(object@Cusip)\n            cat(\"Coupon:\"); print(object@Coupon)\n            cat(\"Frequency:\"); print(object@Frequency)\n            cat(\"Basis:\"); print(object@BondBasis)\n            cat(\"Issue Date:\"); print(object@IssueDate)\n            cat(\"Last Payment Date:\"); print(object@LastPmtDate)\n            cat(\"Next Payment Date:\"); print(object@NextPmtDate)\n            cat(\"Maturity Date:\"); print(object@Maturity)\n            cat(\"Bond Valuation:\", \"\\n\")\n            cat(\"Price:\"); print(object@Price)\n            cat(\"Accrued:\"); print(object@Accrued)\n            cat(\"Yield to Maturity:\"); print(object@YieldToMaturity)\n            cat(\"Risk Metrics:\", \"\\n\")\n            cat(\"Weighted Average Life:\"); print(object@WAL)\n            cat(\"Modified Duration:\"); print(unname(object@ModDuration))\n            cat(\"Convexity:\"); print(unname(object@Convexity))\n            cat(\"Effective Duration\"); print(unname(object@EffDuration))\n            cat(\"Effective Convexity\"); print(unname(object@EffConvexity))\n            cat(\"Sector Detail:\", \"\\n\")\n            cat(\"Bond Type:\"); print(object@BondType)\n            cat(\"Sector:\"); print(object@Sector)\n            cat(\"Moodys:\"); print(object@Moody)\n            cat(\"S&P:\"); print(object@SP)\n            cat(\"BondLab Rating:\");print(object@BondLab)\n            \n            plotdata1 = as.data.frame(cbind(object@Period, object@TotalCashFlow))\n            colnames(plotdata1) <- c(\"Period\", \"CashFlow\")\n            \n            plot1 <- ggplot(plotdata1, aes(x= Period, y = CashFlow)) +\n              geom_bar(stat = \"identity\", width = 1, fill = \"Grey\") +\n              theme_minimal() + \n              labs(fill = \"\") +\n              ylab(\"Mtg. Cash Flow\") +\n              xlab(\"Period\") +\n              theme(axis.title.y=element_text(angle = 90, size = 20)) +\n              theme(axis.text.y = element_text(angle = 90, size = 15)) +\n              theme(axis.title.x=element_text(angle = 0, size = 20)) +\n              theme(axis.text.x = element_text(angle = 0, size = 15)) +\n              theme(legend.position = c(.82,.73))\n            \n            plotdata2 = as.data.frame(cbind(object@KeyRateTenor, object@KeyRateDuration))\n            colnames(plotdata2) <- c(\"KRTenor\", \"KRDuration\")\n            \n            plot2 <- ggplot(plotdata2, aes(x = as.factor(KRTenor), y = KRDuration)) +\n              geom_bar(stat = \"identity\", fill = \"Grey\") +\n              theme_minimal() +\n              labs(fill = \"\") +\n              ylab(\"Key Rate Duration\") +\n              xlab(\"Key Rate Tenor\") +\n              theme(axis.title.y=element_text(angle = 90, size = 20)) +\n              theme(axis.text.y = element_text(angle = 90, size = 15)) +\n              theme(axis.title.x=element_text(angle = 0, size = 20)) +\n              theme(axis.text.x = element_text(angle = 0, size = 15)) +\n              theme(legend.position = c(.82,.73))\n                  \n             multiplot(plot1, plot2, cols = 1)\n            \n          }\n)\n\nsetMethod(\"show\",\n          signature(object = \"DollarRoll\"),\n          function(object){\n          cat(\"Dollar Roll Analysis\", \"\\n\")\n          cat(\"Settlement Date\"); print(object@SettlementDate)\n          cat(\"Settlement Price\"); print(object@Price)\n          cat(\"Drop 32nds\"); print(object@Drop)\n          cat(\"Forward Settlement Date\"); print(object@FwdSettlementDate)\n          cat(\"Forward Price\"); print(object@FwdPrice)\n          cat(\"Beginning Market Value\"); print(object@PrincipalProceeds)\n          cat(\"Accrued Interest\"); print(object@Accrued)\n          cat(\"Roll Proceeds\"); print(object@TotalProceeds)\n          cat(\"Reinvestment Proceeds\"); print(object@ReinvestmentIncome)\n          cat(\"Future Value\"); print(object@FutureValueRoll)\n          cat(\"Dollar Advantage\"); print(object@Advantage)\n          #cat(\"Basis Points (Annualized\"); print(object@BasisPoints)\n          cat(\"Breakeven Drop\"); print(object@DropImpliedValue)\n          cat(\"Hold or Roll\"); print(object@HoldorRoll)\n          cat(\"Scheduled Principal\"); print(object@ScheduledPrin)\n          cat(\"Prepaid Principal\"); print(object@PrepaidPrin)\n          cat(\"Pass Through Interest\"); print(object@PassThroughInterest)\n          cat(\"Remaining Principal\"); print(object@RemainingBalance)\n          cat(\"Proceeds\"); print(object@FuturePrincipalProceeds)\n          cat(\"Hold Accrued\"); print(object@FwdAccrued)\n          cat(\"Future Value\"); print(object@FutureValuePrinCarry)\n          }\n          )\n  \n\n\n",
    "created" : 1397909866416.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3913370696",
    "id" : "5726480F",
    "lastKnownWriteTime" : 1398391843,
    "path" : "~/BondLab/R/BondLab.R",
    "project_path" : "R/BondLab.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}