  # Bond Lab is a software application for the analysis of 
  # fixed income securities it provides a suite of applications
  # in addition to standard fixed income analysis bond lab provides 
  # for the specific analysis of structured products residential mortgage backed securities, 
  # asset backed securities, and commerical mortgage backed securities
  # License GPL3 + File License
  # Copyright (C) 2014  Bond Lab Technologies
  # Fair use of the Bond Lab trademark is limited to promotion of the use of Bond Lab software or 
  # the book "Investing in Mortgage Backed Securities Using Open Source Analytics"
  
 
  # This is the cashflow waterfall for {enter deal name here}
  
  #------------------------------------------------------------------------------------------------- 
  # The below are standard calculations that must be done before the waterfall
  # There are two arrays to the cash waterfall the first acrrued and balance
  # the second is the cash waterfall array
  #-------------------------------------------------------------------------------------------------
  
  #-------------------------------------------------------------------------------------------------
  # Retrieve Collateral Cashflow needed for waterfall allocation
  #-------------------------------------------------------------------------------------------------
  
  Period <- as.numeric(Collateral@Period)
  PmtDate <- as.character(Collateral@PmtDate)
  BeginBal <- as.numeric(Collateral@BeginningBal)
  Interest <- as.numeric(Collateral@PassThroughInterest)
  Scheduled <- as.numeric(Collateral@ScheduledPrin)
  Prepaid <- as.numeric(Collateral@PrepaidPrin)
  TotalPrin <- as.numeric(Collateral@ScheduledPrin + Collateral@PrepaidPrin + Collateral@RecoveredAmount)
  EndBal <- as.numeric(Collateral@EndingBal)
  
  #---------------------------------------------------------------------------------------------------
  # calculate days of acrrued
  #---------------------------------------------------------------------------------------------------
  days.to.nextpmt = (BondBasisConversion(issue.date = issue.date,
                                         start.date = start.date,
                                         end.date = end.date,
                                         settlement.date = settlement.date,
                                         lastpmt.date = lastpmtdate,
                                         nextpmt.date = nextpmt.date) * days.in.year.360)

  # -------------------------------------------------------------------------------------------------- 
  # build a vector of dates for the REMIC payment schedule
  # first get the pmtdate interval payment Frequency
  # --------------------------------------------------------------------------------------------------
 
  payment.frequency = REMIC.Deal@Tranches[[as.numeric(REMIC.Tranche@TrancheNumber)]]@PrinPmtFrequency
  pmtdate.interval = months.in.year/payment.frequency

  
  # -------------------------------------------------------------------------------------------------- 
  # compute the payment dates
  # --------------------------------------------------------------------------------------------------
  
  REMIC.pmtdate = as.Date(c(if(settlement.date == issue.date) 
                          {seq(start.date, end.date, by = paste(pmtdate.interval, "months"))} 
                          else 
                          {seq(nextpmt.date, end.date, by = paste(pmtdate.interval, "months"))}), "%m-%d-%Y")
  
  # ---------------------------------------------------------------------------------------------------
  # build the time period vector (n) 
  # for discounting the cashflows nextpmt date is vector of payment dates to n for each period
  # ---------------------------------------------------------------------------------------------------
  
  REMIC.time.period = BondBasisConversion(issue.date = issue.date, 
                                            start.date = start.date, 
                                            end.date = end.date, 
                                            settlement.date =  settlement.date, 
                                            lastpmt.date = lastpmt.date, 
                                            nextpmt.date = REMIC.pmtdate)
  
  # ===================================================================================================
  # Build collateral cashflow table for the REMIC waterfall
  # ===================================================================================================
  
  CollateralCashFlow <- cbind(Period, PmtDate, BeginBal, Interest, Scheduled, Prepaid, TotalPrin, EndBal)
  NoPeriod <- nrow(CollateralCashFlow)
  NoCol <- REMIC.Deal@NumberofTranches
  
  # ----------------------------------------------------------------------------------------------------
  # get the length of the factor data class to call the last available factor
  # ---------------------------------------------------------------------------------------------------
  FactorRecords <- length(REMIC.Deal@FactorData[[1]]@PaymentDate)
  
  TrancheFactors <- array(data = 0, c(1,NoCol))
  colnames(TrancheFactors) <- c(rep((paste("Tranche_",seq(1:NoCol)))))
  
  for(tf in 1:NoCol){
  TrancheFactors[1,tf] <- REMIC.Deal@FactorData[[tf]]@Factor
  }
  
  # ===================================================================================
  # Dimension Array to hold settlement data
  # Dimension values for tranche interest and principal arrays
  # Table 1 is the current balance, 
  # Table 2 is the acrrued, 
  # Table 3 principal payment
  # Table 4 is proceeds
  # Dim array to hold the variables
  # Populate begin values of the tranches current balance, acrrued interest, proceeds
  # ====================================================================================
  
  TrancheBeginValue <- array(data = 0, c(1, (NoCol), 4))
  
  # -------------------------------------------------------------------------------------
  # Populate the current principal balance
  # -------------------------------------------------------------------------------------
  
  for(pb in 1:NoCol){
  TrancheBeginValue[1,pb,1] <- REMIC.Deal@Tranches[[pb]]@TrancheOrigBal * TrancheFactors[1, pb]
  }
  
  # -------------------------------------------------------------------------------------
  # Populate the acrrued interest
  # -------------------------------------------------------------------------------------
  
  for(ai in 1:NoCol){
  # --- add days to next payment then acrrued can be calculated for any tranche pmt scheme
  frequency = REMIC.Deal@Tranches[[ai]]@InterestPmtFrequency
  days.between.pmtdate = ((months.in.year/frequency)/months.in.year) * days.in.year.360
  days.of.accrued = (days.between.pmtdate - days.to.nextpmt)
  
  TrancheBeginValue[1,ai,2] = (days.of.accrued/days.between.pmtdate) *  
  (REMIC.Deal@Tranches[[ai]]@TrancheCoupon/yield.basis) /  
  REMIC.Deal@Tranches[[ai]]@InterestPmtFrequency * 
  TrancheBeginValue[1,ai,1]                      
  }

  #=====================================================================================
  # compute the principal proceeds 
  # ====================================================================================
  for(prin in 1:NoCol){
  TrancheBeginValue[1,prin,3] <- if(prin != REMIC.Tranche@TrancheNumber) 
                                  {TrancheBeginValue[1,prin,1]} else
                                    {(TrancheBeginValue[1,prin,1] * tranche.price)}
  }
  
  #-------------------------------------------------------------------------------------- 
  # populated  proceeds
  #--------------------------------------------------------------------------------------
  TrancheBeginValue[,,4] <- (TrancheBeginValue[,,2] + TrancheBeginValue[,,3])
    
  #======================================================================================
  #set-up the coupon array this is used to allocate interest 
  #======================================================================================
  CouponArray <- array(data = 0, c(NoPeriod, NoCol))
  
  for(ca.row in 1:NoPeriod){
    for(ca.col in 1:NoCol){
      if(isTRUE(REMIC.Deal@Tranches[[ca.col]]@Fixed)) 
          {CouponArray[ca.row, ca.col] <- (REMIC.Deal@Tranches[[ca.col]]@TrancheCoupon/100)/frequency}
            else
          {CouponArray[ca.row, ca.col] <- REMIC.Deal@Tranches[[ca.col]]@FloaterFormula(
              Index = (TermStructure@forwardrate[ca.row]/100)/frequency,
              FloaterCap = (REMIC.Deal@Tranches[[ca.col]]@FloaterCap/100)/frequency,
              FloaterMargin = (REMIC.Deal@Tranches[[ca.col]]@FloaterMargin/100)/frequency,
              FloaterFloor = (REMIC.Deal@Tranches[[ca.col]]@FloaterFloor/100)/frequency
              )}

    }
  }

  #====================================================================================
  # Dimesion the TrancheCashflow (REMIC) array 
  # columns is the number of tranches, rows correspond to the number cashflows, 
  # TrancheCashFlow array is referred (row, column, table)
  # There are 4 tables,
  # Table 1 = principal bal outstanding, 
  # Table 2 = interest, 
  # Table 3 = principal pmt, 
  # Table 4 = total cashflow
  #====================================================================================
  
  TrancheCashFlow <- array(data = 0, c((NoPeriod + 1), (NoCol), 4))
  colnames(TrancheCashFlow) <- c(rep((paste("Tranche_",seq(1:NoCol)))))
  
  # --- populate the first row of the cashflow array with proceeds
  for(table in 1:4){
    for(column in 1: NoCol){
       TrancheCashFlow[1, column, table] <- 
            if(table != 3) {TrancheBeginValue[1, column, table]} else {0}
    }
  }

  # ===================================================================================
  # Check for Bond Schedules, This should be written to check for more than one schedule
  # ===================================================================================
  
  if(isTRUE(REMIC.Tranche@Schedule)) 
  {schedule <- REMICSchedules(REMIC.Tranche = REMIC.Tranche)} else {schedule <- NULL}
  
  # ----------------------------------------------------------------------------------- 
  # get the REMIC Schedule start value
  # -----------------------------------------------------------------------------------
  
  if(isTRUE(REMIC.Tranche@Schedule)) 
  {schedule.period <- length(as.numeric(REMIC.Deal@FactorData[[as.numeric(REMIC.Tranche@TrancheNumber)]]@PaymentDate))} else 
  {schedule.period <- NULL}

  # ================================================================================= 
  # The A150 and F4 are paid ProRata
  # Calculate each principal payment ratio before water fall loop
  # =================================================================================
  
  #-----------------------------------------------------------------------------------
  CombinedBal = sum(REMIC.Deal@Tranches[[2]]@TrancheOrigBal,REMIC.Deal@Tranches[[3]]@TrancheOrigBal)
  A150Ratio = REMIC.Deal@Tranches[[2]]@TrancheOrigBal / CombinedBal
  F4$Ratio = REMIC.Deal@Tranches[[3]]@TrancheOrigBal / CombinedBal
  #-----------------------------------------------------------------------------------
  
  # =================================================================================
  # This deal has exchangeable pass-through classes
  # Calaculate the pro-rata share of principal paid to each exchangeable pass-through
  # =================================================================================
  
  #----------------------------------------------------------------------------------
  CollBalance <- REMIC.Deal@CollateralAmount
  A175Ratio <- REMIC.Deal@Tranches[[4]]@TrancheOrigBal /  CollBalance
  A200Ratio <- REMIC.Deal@Tranches[[5]]@TrancheOrigBal /  CollBalance
  A220Ratio <- REMIC.Deal@Tranches[[6]]@TrancheOrigBal /  CollBalance
  A225Ratio <- REMIC.Deal@Tranches[[7]]@TrancheOrigBal /  CollBalance
  A250Ratio <- REMIC.Deal@Tranches[[8]]@TrancheOrigBal /  CollBalance
  A275Ratio <- REMIC.Deal@Tranches[[9]]@TrancheOrigBal /  CollBalance
  A300Ratio <- REMIC.Deal@Tranches[[10]]@TrancheOrigBal /  CollBalance
  A325Ratio <- REMIC.Deal@Tranches[[11]]@TrancheOrigBal /  CollBalance
  A350Ratio <- REMIC.Deal@Tranches[[12]]@TrancheOrigBal /  CollBalance
  A375Ratio <- REMIC.Deal@Tranches[[13]]@TrancheOrigBal /  CollBalance
  A400Ratio <- REMIC.Deal@Tranches[[14]]@TrancheOrigBal /  CollBalance
  A425Ratio <- REMIC.Deal@Tranches[[15]]@TrancheOrigBal /  CollBalance
  A450Ratio <- REMIC.Deal@Tranches[[16]]@TrancheOrigBal /  CollBalance
  A475Ratio <- REMIC.Deal@Tranches[[17]]@TrancheOrigBal /  CollBalance
  A500Ratio <- REMIC.Deal@Tranches[[18]]@TrancheOrigBal /  CollBalance
  A525Ratio <- REMIC.Deal@Tranches[[19]]@TrancheOrigBal /  CollBalance
  A550Ratio <- REMIC.Deal@Tranches[[20]]@TrancheOrigBal /  CollBalance
  #----------------------------------------------------------------------------------
  # =================================================================================
  # This section begins the cash flow waterfall of the REMIC
  # Allocate principal and interest to the tranches according to payment rules 
  # Note waterfall allocation of principal and interest always begins in row 2
  # ==================================================================================
  
  for(waterfall in 2:NoPeriod){

  #-----------------------------------------------------------------------------------
  # Pay interest NoCol = number of period (rows)
  #-----------------------------------------------------------------------------------
  for(payment in 1:NoCol)
  {TrancheCashFlow[waterfall, payment, 2] <- as.numeric(CouponArray[waterfall-1, payment]) * 
                                              as.numeric(TrancheCashFlow[waterfall-1, payment, 1])}
  
  #------------------------------------------------------------------------------------
  # Pay Principal
  # Tranche S4 [3] is a notional Inverse IO principal payment is zero
  # Tranche 
  #------------------------------------------------------------------------------------
  if(payment <= 2)
  TrancheCashFlow[waterfall, payment, 3] <- as.numeric(CollateralCashFlow[waterfall, 7])] * A150Ratio
  TrancheCashFlow[waterfall, payment, 3] <- as.numeric(CollateralCashFlow[waterfall, 7]) * F4Ratio
  TrancheCashFlow[waterfall, payment, 3] <- 0
  
  #====================================================================================
  # Exchangable floater/inverse IO class principal waterfall
  #====================================================================================
  #------------------------------------------------------------------------------------
  # Pay Principal to the floater and inverse floater exchangable classes
  #------------------------------------------------------------------------------------
  #assign zero principal payment to all notional classes.
  #Note: Tranches 21, 23, 25, 27, and 29 principal payment is equal to F4 Tranche
  if(REMIC.Deal@Tranches[[payment]]@TrancheNumber %in% as.character(c(21, 23, 25, 27, 29)) == 'TRUE'){
  TrancheCashFlow[waterfall, payment, 3] <- as.numeric(TrancheCashFlow[waterfall, 2, 3])}
  
  #Note: Traches 22, 24, 26, 28, and 30 are exchangeable notional tranches 
  if(REMIC.Deal@Tranches[[payment]]@TrancheNumber %in% as.character(c(22, 24, 26, 28, 30)) == 'TRUE'){
  TrancheCashFlow[waterfall, payment, 3] <- 0}
  
  #------------------------------------------------------------------------------------
  # Calculate the tranche ending balance.
  # -----------------------------------------------------------------------------------
  for(balance in 1:NoCol){
  TrancheCashFlow[waterfall, balance, 1] <-
    as.numeric(TrancheCashFlow[waterfall - 1, balance, 1]) - 
      as.numeric(TrancheCashFlow[waterfall, balance, 3])}
      
  #-------------------------------------------------------------------------------------
  # Calculate the Tranche Ending Balance
  #-------------------------------------------------------------------------------------
  
  for(tranche in 1:NoCol){
  TrancheCashFlow[waterfall, tranche, 4] <- as.numeric(TrancheCashFlow[waterfall, tranche, 2]) +
                                            as.numeric(TrancheCashFlow[waterfall, tranche, 3])}
  
  }
  
  #====================================================================================
  # End of Waterfall For Loop
  #====================================================================================
  
  #====================================================================================
  # This section begins the waterfall footer
  # Output of the REMIC Tranche cashflow data
  #====================================================================================

  Period <- Collateral@Period
  PmtDate <- as.character(REMIC.pmtdate)
  TimePeriod <- REMIC.time.period
  Interest <- TrancheCashFlow[2:(NoPeriod + 1), as.numeric(REMIC.Tranche@TrancheNumber),2]
  Principal <- TrancheCashFlow[2:(NoPeriod + 1), as.numeric(REMIC.Tranche@TrancheNumber), 3]
  TrancheCF <- TrancheCashFlow[2:(NoPeriod + 1),as.numeric(REMIC.Tranche@TrancheNumber),4]


  REMICCashFlow <- as.matrix(cbind(Period, PmtDate, TimePeriod, Interest, Principal, TrancheCF ))